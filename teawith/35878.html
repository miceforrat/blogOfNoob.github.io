<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>OSLab4随笔 | 下午六点的茶会</title><meta name="author" content="Mad Hatter"><meta name="copyright" content="Mad Hatter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="​		如题，现在终于有时间来整理一下Lab4的内容了。不过Lab4的内容着实不多，而且相关的伪代码&#x2F;代码要么ORANGE’S上面有，要么《操作系统教程》上面有(PV操作的伪代码)，要么助教补充的细节里面有，要么葛老师的PPT里有（读者优先），所以实现起来应该还好。但是，就算这样，我们还是得知道我们手头的东西里面有什么。 ​		我看了下提问好像还会问到第7章相关的内容，有点难绷。 ​		第">
<meta property="og:type" content="article">
<meta property="og:title" content="OSLab4随笔">
<meta property="og:url" content="https://miceforrat.github.io/blogOfNoob.github.io/teawith/35878.html">
<meta property="og:site_name" content="下午六点的茶会">
<meta property="og:description" content="​		如题，现在终于有时间来整理一下Lab4的内容了。不过Lab4的内容着实不多，而且相关的伪代码&#x2F;代码要么ORANGE’S上面有，要么《操作系统教程》上面有(PV操作的伪代码)，要么助教补充的细节里面有，要么葛老师的PPT里有（读者优先），所以实现起来应该还好。但是，就算这样，我们还是得知道我们手头的东西里面有什么。 ​		我看了下提问好像还会问到第7章相关的内容，有点难绷。 ​		第">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-22T15:14:32.000Z">
<meta property="article:modified_time" content="2023-06-08T11:25:44.551Z">
<meta property="article:author" content="Mad Hatter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/blogOfNoob.github.io/img/favicon.png"><link rel="canonical" href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/35878.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blogOfNoob.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blogOfNoob.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OSLab4随笔',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-08 19:25:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/blogOfNoob.github.io/atom.xml" title="下午六点的茶会" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blogOfNoob.github.io/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/blogOfNoob.github.io/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/blogOfNoob.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blogOfNoob.github.io/img/path.png')"><nav id="nav"><span id="blog-info"><a href="/blogOfNoob.github.io/" title="下午六点的茶会"><span class="site-name">下午六点的茶会</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OSLab4随笔</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-22T15:14:32.000Z" title="Created 2023-05-22 23:14:32">2023-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-08T11:25:44.551Z" title="Updated 2023-06-08 19:25:44">2023-06-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OSLab4随笔"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>​		如题，现在终于有时间来整理一下Lab4的内容了。不过Lab4的内容着实不多，而且相关的伪代码&#x2F;代码要么ORANGE’S上面有，要么《操作系统教程》上面有(PV操作的伪代码)，要么助教补充的细节里面有，要么葛老师的PPT里有（读者优先），所以实现起来应该还好。但是，就算这样，我们还是得知道我们手头的东西里面有什么。</p>
<p>​		我看了下提问好像还会问到第7章相关的内容，有点难绷。</p>
<p>​		第三部分按照顺序整理了问答。</p>
<p><a href="#chapter1">1. 搭建多进程</a></p>
<p><a href="#chapter1.1">1.1 从程序到进程</a></p>
<p><a href="#chapter1.2">1.2 进程的变换</a></p>
<p><a href="#chapter1.2.1">1.2.1 先跳出内核</a></p>
<p><a href="#chapter1.2.2">1.2.2调度的发生时机</a></p>
<p><a href="#chapter1.3">1.3 系统调用</a></p>
<p><a href="#chapter2">2. 扩张与陷阱</a></p>
<p><a href="#chapter2.1">2.1 增加系统调用：带参数</a></p>
<p><a href="#chapter2.1.1">2.1.1 睡眠与打印</a></p>
<p><a href="#chapter2.1.2">2.1.2 信号量的构造</a></p>
<p><a href="#chapter2.2">2.2 增加进程</a></p>
<p><a href="#chapter2.3">2.3 两个问题</a></p>
<p><a href="#chapter3">3 OSLab4问答试整理</a></p>
<p><a href="#chapter3.1">3.1 进程</a></p>
<p><a href="#chapter3.2">3.2 进程表</a></p>
<p><a href="#chapter3.3">3.3 进程栈</a></p>
<p><a href="#chapter3.4">3.4 esp的指向</a></p>
<p><a href="#chapter3.5">3.5 tty</a></p>
<p><a href="#chapter3.6">3.6 tty与显存</a></p>
<p><a href="#chapter3.7">3.7 tty任务的执行过程</a></p>
<p><a href="#chapter3.8">3.8 tty结构体</a></p>
<p><a href="#chapter3.9">3.9 console结构体</a></p>
<p><a href="#chapter3.10">3.10 时间片</a></p>
<p><a href="#chapter3.11">3.11 内核函数与系统调用</a></p>
<h1 id="搭建多进程"><a href="#搭建多进程" class="headerlink" title="搭建多进程"></a><a id="chapter1">搭建多进程</a></h1><p>​		这里我们需要从第6章开始来继续读书。在第5章（见Lab3）中，我们已经实现了GDT和IDT，这样可以支持一些基本的保护模式寻址和中断的行为了。然而，要进行这一次的实验，<strong>进程</strong>的实现显然是必不可少的。就跟着书上的脚步，来搭建出一个个进程吧。</p>
<h2 id="从程序到进程"><a href="#从程序到进程" class="headerlink" title="从程序到进程"></a><a id="chapter1.1">从程序到进程</a></h2><p>​		快到期末了，这里也顺便整理一下各种各样的思路，来探讨一下，进程到底为何存在？</p>
<p>​		我们的程序其实有很多的“依赖”，比如说一些特定的程序可能需要<strong>栈</strong>，再比如我们的程序也有自身所需要的<strong>数据</strong>，对于一个程序而言，这些事物的存在似乎是天经地义的。如果我们足够耐心，我们也可以等工作一件一件去做。可是人终究是会追求一些更高的东西的——比如更高的运行效率，更短的<strong>总运行时间</strong>。纯粹串行执行是有瓶颈的——比如IO外设的数据传输速度会让执行这个程序的处理器花费相当的时间去等它完成I&#x2F;O。所以我们需要在这个时候把处理器让出来给其他的程序。然而，踢掉一个程序是很容易的，可是怎么把他加回来呢？程序和程序之间的数据和栈可能是完全没有交集的，我们该怎么记住上一次，甚至前面几次占有处理器的程序呢？所以，我们需要一个容器，<strong>至少</strong>能来保存这些必要的信息。基于这种想法，便能想到所谓的<strong>进程</strong>——从实现上来说，它本质上也不过是一种<strong>保存了一些关键信息的数据结构</strong>罢了。</p>
<p>​		另一个问题是，进程调度何时发生？</p>
<p>​		一个容易想到的情况就是，当进程实在跑不下去的时候，他自然就需要让出处理器了。这时我们便可以剥夺这个进程的处理器资源，交给一个其他的进程。书上考虑了一种在实现上更简单的情况——也就是在时钟中断时进行调度。</p>
<p>​		前面我们并没有讲清楚，在进程切换的时候，应当保存什么，因为这部分最好合着一些实际的内容一起讲。</p>
<p>​		这个问题的等价提法是，列出一个程序需求的所有内容，然后找出在其他程序运行时可能修改的部分。</p>
<p>​		我们可以先假定内存足够大，于是可以认为各个程序存储在内存中的数据和代码是互不干涉的。栈说来神秘，实际上他也<strong>不过是一块内存区域</strong>——只不过我们可以通过ss和esp特定地拿到它的位置，就像eip和cs一样。所以，我们实际上只需要保存<strong>这些区域在哪里</strong>。同时，我们可能还有一些临时计算的值需要进行保存。简单来说，我们需要保存的是寄存器的值。</p>
<p>​		那么怎么保存呢？我们上面说过，应该有一个单独的数据结构来存储需要存储的关键信息。所以我们要做的无非是<strong>将寄存器中的数据传送到某个特定的内存区域</strong>。然而，我们完全没有必要自己去写一套传送的方法。在上一段中，我提过，栈不过是一块内存区域，于是我们只需要让存储进程的相关信息的数据结构的区域<strong>被认为是一块堆栈</strong>——也就是让esp指向这个区域，然后我们就可以<strong>用push和pop指令</strong>进行这块内存和寄存器的信息交换——INTEL甚至提供了<strong>pushad</strong>这个指令（但是段寄存器不会入栈），来把所有寄存器的值都<strong>依据一个特定的顺序</strong>保存进栈里。</p>
<p>​		这一块区域也就属于我们OS课上教的<strong>进程控制块</strong>，下面的讲述中，尽管和ORANGE’S不同，我还是用进程控制块而不是<strong>进程表</strong>这个概念（ORANGE’S<strong>在这里</strong>对进程表的说法是和进程控制块等价，后面还出现了一些可能矛盾的表述；而从我查到的情况来看，一些出现进程表的表述会用<strong>进程表项</strong>来表示进程控制块）。</p>
<p>​		当然，由于一些概念尚未讲到，所以这里还是有可能遗漏一些保存内容的，不过下面也会进行补充。</p>
<h2 id="进程的变换"><a href="#进程的变换" class="headerlink" title="进程的变换"></a><a id="chapter1.2">进程的变换</a></h2><p>​		这一部分的任务仍然并不单一，我们可以再想一想，先从哪一步去入手。</p>
<p>​		既然我们有了进程表，所以我们只需要<strong>从某个指定的进程控制块里pop数据到寄存器</strong>，就可以设置上下文，从未让处理器运行对应的进程。这些内容显然不可能交给用户进程去完成，只能给内核去完成。所以书上先实现了从用户进程跳入内核，再从内核跳回用户进程的操作。</p>
<h3 id="先跳出内核"><a href="#先跳出内核" class="headerlink" title="先跳出内核"></a><a id="chapter1.2.1">先跳出内核</a></h3><p>​		一开始我们是在内核态的，所以不妨先从<strong>ring 0</strong>跳到用户进程的特权级，同时这一个从无到有的过程也能让我们更加明确后续进行进程切换的时候需要设置哪些东西。</p>
<p>​		在一切操作之前，我们不妨先给自己减减负，比如允许我们用C语言编写多数代码，于是我们可以在kernel.asm中找到下列代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp kernel_main</span><br></pre></td></tr></table></figure>

<p>​		这里的kernel_main函数正是在main.c中，我们可以在这个函数中完成一些数据初始化的事情。</p>
<p>​		从Lab3的讲述中，我们知道，可以在栈中预先压入对应的值（ss,esp,eflags,cs,eip），调用<strong>iretd</strong>时，就会自动将栈中这些值pop入对应的寄存器，从而可以指定接下来执行的代码段和对应的堆栈段，同时设置相应的标志寄存器的情况。</p>
<p>​		不过，我们尚有一些其他的情况要去考虑。虽然我们上文认为不同程序的内存上是互不干涉的，但这实际上有一个前提条件，那就是一个进程不应该歪打正着地<strong>寻址到属于另一个进程的地址</strong>，所以，对应的段描述符<strong>不应该被放在GDT里</strong>——这些谁都能碰得到，保不齐哪个进程脑洞大开一下就接触到另一个进程的内容了呢？所以，我们应该引入<strong>LDT（局部描述符表）</strong>。LDT的寻址方式我在Lab2的问题回答当中已然写过，在这就不再重复了。这一种寻址方式使得我们可以通过<strong>LDTR</strong>来选择使用哪一个LDT，而用户进程不应该能够自由地设置LDTR。不过这又引出了一些新的问题，比如LDT放哪，LDTR的值又应该放哪呢？</p>
<p>​		以ORANGE’S的实现为例，LDT就是放在<strong>进程的结构体</strong>（<strong>s_proc</strong>）里边的。同时，考虑到对于<strong>同一个进程</strong>，<strong>LDTR是不变的</strong>，而且pushad也不会将LDTR中的选择子推入栈中，所以我们单独开一个成员来存这个<strong>确定的选择子</strong>即可。同时，我们还要在GDT中加入LDT的段描述符以供查询。</p>
<p>​		无论是进程表的初始化还是ldt的设置，我们都可以在main.c中的<strong>kernel_main</strong>函数中找到。其中有一些位运算的内容，如果想要深究，可以将相关寄存器里应该存的值和初始化赋值时位运算的结果进行一下比对，这样可以进一步理解相关的内容。</p>
<p>​		考虑到我们会有多个进程，所以我们需要一个特别的数组来存储我们的进程们（书上也叫他进程表，这里为了区别以及考虑到一致性的问题，我下面的叙述会用<strong>进程列表</strong>来加以区别，尽管可能并不存在这样一个名词），这样一个列表在global.c中，我们可以通过修改<strong>proc.h中的NR_TASKS</strong>的值以及在数组初始化时增加一个成员来增加新的进程——当然，新的工作可能并不止这些，我后文还会总结。</p>
<p>​		除了kernel_main中有初始化工作外，<strong>protect.c中的init_prot函数</strong>也做了一部分的工作，具体来说，是增加GDT中的相关描述符。</p>
<p>​		最后，考虑到从用户特权级进入内核特权级需要用到TSS，这里需要再初始化一下TSS——是的，第五章的代码甚至都没有做这个工作。除此之外，还需要在GDT中加入一个TTS的描述符。</p>
<p>​		做完信息初始化后，我们可别忘了，即使是kernel_main也还是在内核态下的，我们要通过iretd指令跳到用户态。于是这里ORANGE又写了一个汇编函数<strong>restart，在kernel.asm中</strong>。它的工作是将必要的寄存器的值（通过从栈中弹出）进行设置从而确保后续的正确运行。因此，一上来就将esp指向了<strong>p_proc_ready</strong>，等价于将要运行的程序的程序控制块。</p>
<p>​		这其中有这么四条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov	esp, [p_proc_ready]</span><br><span class="line">lldt	[esp + P_LDT_SEL] </span><br><span class="line">lea eax, [esp + P_STACKTOP]</span><br><span class="line">mov	dword [tss + TSS3_S_SP0], eax</span><br></pre></td></tr></table></figure>

<p>​		这里的lea是<strong>load effective address</strong>，装入有效地址的意思。他将esp+P_STACKTOP对应得到的值作为地址装入了eax。</p>
<p>​		将这四条连起来看，我们可以简单地认为是将esp指向下一个要运行的进程的进程控制块，然后后面的esp+P_STACK_TOP需要结合proc.h中的s_proc定义来看，其值是<strong>p_proc_ready的reg成员的末地址</strong>。后面有一个宏定义TSS3_S_SP0，这个意思是esp 0的偏移，所以就是将p_proc_ready的reg成员的末地址（栈是<strong>从高往低</strong>生长的）存到<strong>TSS的esp 0</strong>中，这样，若要从用户进程进入内核态，栈指针就会先指向这里，将堆栈段寄存器、栈指针寄存器、代码段寄存器、指令指针寄存器等的值压栈（这是call这个指令的功能）后，就可以进一步pushad保存其他寄存器的值。</p>
<p>​		到此为止，可以从内核态跳入用户态了。</p>
<h3 id="调度的发生时机"><a href="#调度的发生时机" class="headerlink" title="调度的发生时机"></a><a id="chapter1.2.2">调度的发生时机</a></h3><p>​		那么用户态什么情况下会跳回内核态呢？比如<strong>中断发生</strong>的时候，用户程序将不得不把控制权交给内核。</p>
<p>​		自然地，书上开始<strong>扩充时钟中断</strong>的内容。</p>
<p>​		为了保证能<strong>后面能回到进入内核态的用户程序的正确位置</strong>，我们需要<strong>保存现场</strong>。由于上个部分中，我们已经设置过TSS的esp 0，且call的时候已经做了一定的处理，所以此时我们跳到了进程控制块的起始位置，从而可以放心地压入一些寄存器的值。自然，返回的时候我们还需要通过从进程控制块中弹出值来恢复这些寄存器的值。同时。</p>
<p>​		然而，一个值得注意的点是，我们需要在保存现场之后立即<strong>切换到内核栈</strong>，不然一些内核态下的栈操作可能会破坏现场。同时，在准备返回时，我们还要让栈指针回到将要运行的进程控制块所在处（p_proc_ready），然后弹出相关的值到寄存器中。</p>
<p>​		这里实际上就有我们可以操作的点了。我们实际上只要在内核态时<strong>修改p_proc_ready</strong>，就可以<strong>返回到不同的用户进程</strong>，从而完成了进程切换。</p>
<p>​		还要注意一个可能遗漏的地方，那就是<strong>TSS的esp 0</strong>，这是每次切换到内核态时我们保存相关寄存器的位置。如果我们切换了进程，却没有修改这个esp 0，下次进入内核态时，就会<strong>污染其他进程的已经保存的寄存器</strong>。所以我们在从内核态返回之前，必须要再次设置TSS的esp 0。同样的，像<strong>ldtr中的选择子</strong>也需要在中断处理时进行替换。</p>
<p>​		最后，代码还进行了一些中断重入的处理。具体来说，就是中断重入不再切换栈等。</p>
<p>​		到这里，基本上<strong>一个进程</strong>在<strong>内核间的反复横跳</strong>已经完成了，后续要做的就是增加新的进程，以及封装进程调度的代码了。</p>
<p>​		</p>
<h3 id="从一到多"><a href="#从一到多" class="headerlink" title="从一到多"></a><a id="chapter1.2.3">从一到多</a></h3><p>​		接下来应当再增加一个进程，不过具体怎么加我后文还会再具体写出来。</p>
<p>​		在这里，作者需要做的是将原来对一个进程的初始化一般化。比如，作者用了一个数组来存储进程所执行的<strong>任务</strong>（相关的定义在global.h中，而数组内容的填充在global.c中），在初始化进程控制块的时候进行一定的搬运即可。</p>
<p>​		同样的，我们在init_prot这个函数中也要将<strong>LDT的描述符的初始化</strong>循环化。</p>
<p>​		至此，作者加入了一个clock_handler函数（clock.c），在汇编代码中调用之，然后在c代码中替换了proc_ready为另一个进程。</p>
<p>​		后面就是一些中断处理代码的优雅化一点的重构了。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><a id="chapter1.3">系统调用</a></h2><p>​		这次Lab还有一个重头戏，那就是系统调用。</p>
<p>​		其实系统调用不过就是把一件事情交给系统去做，用户进程只要知道结果就可以了。</p>
<p>​		而在ORANGE至此为止的实现中，用户进程何时可以跳入内核态呢？<strong>中断的时候</strong>。</p>
<p>​		所以我们只需要将系统调用作为一种分配了特定中断向量号的特殊的中断就好了。这也使得系统调用的初步处理需要在<strong>汇编</strong>中进行（但是汇编很明显容易犯各种各样的错误）。而对于不同类型的系统调用，我们可以通过<strong>修改eax寄存器的值</strong>来加以设定。如果有参数，我们还要用其他寄存器存储参数（后文会写增加系统调用的步骤和坑）。</p>
<p>​		在做完参数设置之后，我们就可以把工作交给中断处理例程了。</p>
<p>​		中断处理例程会按照情况进一步调用不同的中断处理函数，于是接下来又到需要我们发挥的地方了，当中断处理例程把控制权交给我们的<strong>系统调用处理函数</strong>后，我们可以用eax中的值，通过<strong>表驱动</strong>的方式，调用不同的例程——在调用例程之前需要先把参数<strong>按顺序从寄存器中压入栈中</strong>（至少32位是这样的）。</p>
<p>​		最后，系统调用表结合<strong>系统调用号</strong>（eax中的值）将会指向我们写好的相关函数，完成系统调用。</p>
<h1 id="扩张与陷阱"><a href="#扩张与陷阱" class="headerlink" title="扩张与陷阱"></a><a id="chapter2">扩张与陷阱</a></h1><p>​		其实第6章还有一部分关于进程调度的内容。不过这部分做的事情主要就是把调度功能通过<strong>schedule函数</strong>封装起来，放置在了<strong>proc.c</strong>里面。</p>
<p>​		我写的时候是按照要求用的第6章的代码（不过我建议用第7章写，主要是第7章提供了非常方便的输出机制）。</p>
<p>​		由于这本书的内容包括一些前辈的遗产已经比较老了，照搬代码还是有可能出现一些问题，所以这里我还会整理一下一些内容添加的过程。</p>
<h2 id="增加系统调用：带参数"><a href="#增加系统调用：带参数" class="headerlink" title="增加系统调用：带参数"></a><a id="chapter2.1">增加系统调用：带参数</a></h2><p>​		如果只是抽象地讲的话，整个过程还是不太好理解，不如拿一个具体的函数来做示范——比如睡眠函数。当然这部分书上也有阐释（在第7章，<strong>294页开始</strong>，简单的版本在第295页的表7.6），但是中间可能还是有些<strong>啸问题</strong>。</p>
<h3 id="睡眠与打印"><a href="#睡眠与打印" class="headerlink" title="睡眠与打印"></a><a id="chapter2.1.1">睡眠与打印</a></h3><p>​		如果我们要加入一个sleep系统调用（参数为时间），根据系统调用的处理过程，我们需要做下列事情：</p>
<p>​		第一阶段：<strong>sleep函数调用阶段</strong>。为了保证这个阶段正常进行，我们需要在proto.h中加入一个函数定义，比如说是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> milli_time)</span>;</span><br></pre></td></tr></table></figure>

<p>​		然后我们要去syscall.asm中加入这么几条：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_NR_sleep	equ	1	;这个看情况，如果之前有别的系统调用号，这个数字就顺延递增</span><br><span class="line"></span><br><span class="line">global sleep	;让外面的代码文件知道有sleep这么个函数</span><br></pre></td></tr></table></figure>

<p>​		接下来我们还是在syscall.asm中<strong>加入sleep的函数体</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sleep:</span><br><span class="line">    mov eax, _NR_sleep</span><br><span class="line">    push ebx</span><br><span class="line">    mov ebx, [esp+8]</span><br><span class="line">    int INT_VECTOR_SYS_CALL</span><br><span class="line">    pop ebx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>​		这里注意和书上不同的是，我们不能直接修改ebx的值，不然后续的寻址可能产生其他的一些问题，我们需要通过栈保存相应寄存器的值，中断之后再pop出来。</p>
<p>​		第二阶段：<strong>中断处理例程阶段</strong>。这一部分没什么要改的。</p>
<p>​		第三阶段：<strong>特定中断（系统调用类中断）处理阶段</strong>。这一部分我们需要注意，如果有参数的话应当<strong>按照顺序压入参数</strong>，这需要修改<strong>kernel.asm中的sys_call函数</strong>。可以注意到，这个函数中原原本本有这个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    [sys_call_table + eax * 4]</span><br></pre></td></tr></table></figure>

<p>​		所以我们需要去找到<strong>sys_call_table</strong>，它的初始化在<strong>global.c</strong>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC  system_call       sys_call_table[NR_SYS_CALL] = &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>​		在这里，我们需要再<strong>在proto.h中定义函数sys_sleep</strong>，将他作为一个成员加到<strong>sys_call_table</strong>中，同时将<strong>NR_SYS_CALL的值加一</strong>（在const.h中）。</p>
<p>​		第四阶段：<strong>特定系统调用（比如sys_sleep）处理阶段</strong>。这一阶段我们只需要编写函数实现睡眠即可。</p>
<p>​		类似地，我们还可以写一下打印的实现。如果是从第7章的代码出发，就比较轻松了。我们可以直接<strong>调out_char进行打印</strong>。如果在第6章，我们还得自己写个写显存的简单机制。不建议调用disp_str，作为一个复杂函数，它直接操作了寄存器，可能带来一些意想不到的结果（甚至有可能是不多写点东西不会出现的结果）。</p>
<h3 id="信号量的构造"><a href="#信号量的构造" class="headerlink" title="信号量的构造"></a><a id="chapter2.1.2">信号量的构造</a></h3><p>​		还有两个系统调用：<strong>信号量的PV操作</strong>需要实现。</p>
<p>​		这两个的伪代码，其实<strong>《操作系统教程》</strong>中也给出了，现抄录如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore s)</span>&#123;</span><br><span class="line">    s.value--;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(s.<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore s)</span>&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(s.<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		相关的解释无论是教材上还是jyy的视频里还是葛老师的课上或是PPT上都给出了。简单地说，value成员体现了信号量的供求情况。在P操作之后，value成员仍然大于0说明供大于求，资源可以被直接获得；如果value成员小于0，则说明<strong>供不应求</strong>，执行P操作的进程应该开始等待资源（进入睡眠，将<strong>不具备获得时间片的资格</strong>）。类似地，V操作之后，如果value成员小于等于0，则说明<strong>还有人正在等待资源</strong>，应当唤醒一个进程，注意这里<strong>只是唤醒</strong>，而不是强行把资源塞给它让它运行。如果value大于0，则说明甚至还有资源结余，即无进程处于等待状态。</p>
<p>​		具体实现的时候需要注意，当唤醒（释放）一个节点（如果偷懒直接用s_proc作为结点）时，应当将其next指针清0，防止后续P操作添加节点到末尾时出现问题。</p>
<p>​		完成这两个系统调用后，我们实际上具备了<strong>构造一个原子化的密室</strong>的条件，这将有助于我们后面的实现。</p>
<h2 id="增加进程"><a href="#增加进程" class="headerlink" title="增加进程"></a><a id="chapter2.2">增加进程</a></h2><p>​		下一步要做的事情是增加进程，由于我是基于第六章的代码进行的功能书写，所以我这里给出的方法不一定适合基于第7章的功能书写。我后面问了别人可能顺便写在下面。（问了下whm，好像没什么区别）。</p>
<p>​		这个方法来自于ORANGE<strong>第207页</strong>。考虑到版本差别，现也用我自己的逻辑叙述如下：</p>
<p>​		还是从程序所需的内容入手。代码段和堆栈段通过<strong>将函数加入TASK_TABLE</strong>的方式即可解决。这需要我们<strong>在proto.h中定义一个函数</strong>，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">observer</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>​		然后我们找到TASK_TABLE：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC  TASK   task_table[NR_TASKS] = &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>​		我们需要把宏<strong>NR_TASKS</strong>加1，同时复制一份表项加进去。</p>
<p>​		由于表项中需要一个新的堆栈段的size，于是我们<strong>重新去proc.h中定义一个</strong>，再修改<strong>STACK_SIZE_TOTAL</strong>的值。</p>
<p>​		到这里为止，我们已经加入了一个进程。接下来，只要<strong>完善进程的函数体</strong>即可。</p>
<h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a><a id="chapter2.3">两个问题</a></h2><p>​		上面两个技术算是比较基本的。而对于这次需要实现的两个经典问题，我打算只简单讲一下——这实在是因为讲述这些经典问题的<strong>互联网资源</strong>实在是太多了。</p>
<p>​		首先是<strong>读者写者问题</strong>。读者群体和写者之间需要有一把互斥锁。这个互斥锁应该初值为1，从而保证在<strong>有读者或者有写者的时候</strong>，另一方无法进行操作。由于<strong>不允许多个写者一起写</strong>，所以这个互斥锁可以顺带用来作为写者和写者之间的互斥锁。写者获取和释放锁的情况是简单的。但是对于读者来说，必须限制<strong>第一个进入临界区的读者才能获取写锁</strong>，不然其他读者尝试获取锁时也会被拒之门外，所以我们需要一个计数<strong>来计算临界区内的读者数</strong>。显然，这个值的<strong>增减和判断应当是原子化的</strong>，否则可能出现两个读者增加计数后使count为2，从而没有一个读者想要主动获得写锁。如果存在读者数量，我们还要加一把数量锁。</p>
<p>​		伪代码如下：	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">int</span> work_ticks, <span class="type">int</span> rest_ticks)</span> &#123;</span><br><span class="line">	P(&amp;reader_register); <span class="comment">//读者进入“读者信息登记区域”，可以认为这里有一道门</span></span><br><span class="line">    reader_cnt++;		 <span class="comment">//读者将读者数+1</span></span><br><span class="line">	<span class="keyword">if</span> (reader_cnt == <span class="number">1</span>)&#123;</span><br><span class="line">		P(&amp;writer_lock); </span><br><span class="line">    &#125;<span class="comment">//如果这是第一个读者，他应该获取写锁</span></span><br><span class="line">	V(&amp;reader_register);<span class="comment">//读者离开这个区域，唤醒其他等待注册的读者</span></span><br><span class="line">	</span><br><span class="line">	P(&amp;reader_cnt_lock);<span class="comment">//读者进入工作区，工作区内的最大读者数量取决于初值</span></span><br><span class="line">	do_read(work_ticks);		<span class="comment">//工作</span></span><br><span class="line">	V(&amp;reader_cnt_lock);<span class="comment">//读者离开工作区，如果有等待的读者，将他唤醒</span></span><br><span class="line">	</span><br><span class="line">	P(&amp;reader_register);<span class="comment">//读者进入“读者信息登记区域”，准备登记退出。</span></span><br><span class="line">    reader_cnt--;		<span class="comment">//这个读者将读者数-1</span></span><br><span class="line">	<span class="keyword">if</span> (reader_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">		V(&amp;writer_lock); </span><br><span class="line">    &#125;<span class="comment">//如果他是工作区域内的最后一个离开的读者，他应该释放写锁。</span></span><br><span class="line">	V(&amp;reader_register);</span><br><span class="line">    </span><br><span class="line">    rest(rest_ticks);<span class="comment">//休息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">(<span class="type">int</span> work_ticks, <span class="type">int</span> rest_ticks)</span> &#123;</span><br><span class="line">	P(&amp;writer_lock);	<span class="comment">//获取写锁</span></span><br><span class="line">	do_write(work_ticks);</span><br><span class="line">	V(&amp;writer_lock);	<span class="comment">//释放写锁</span></span><br><span class="line">	rest(rest_ticks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个结构算是比较烂大街了。而且，根据这个需求实现出来的读者写者问题的模拟天然地具有<strong>读者优先</strong>的性质。</p>
<p>​		那写者优先怎么实现呢？上述的方法出现的最大问题是，对于读者的登记，几乎没有限制——只要读者能把写锁牢牢地握在手中，很有可能源源不断地进入工作区。而且读者和另一个写者如果要<strong>等候写锁</strong>，也纯是看先来后到，并不能确保写者对写锁的优势。</p>
<p>​		所以，可以在读者的注册区域外再套一把锁，这把锁<strong>将握在写者们的手中</strong>。同时由于需要<strong>对写者实现和读者类似的计数工作</strong>，所以我们还需要<strong>给写者的“注册”加一把互斥锁</strong>。</p>
<p>​		这些烂大街的工作到处都能查得到，我就不赘述了。这里讨论一下怎么防止饥饿。</p>
<p>​		窃以为用公平读写应该是不行的——<strong>临时</strong>更换一种策略的话，如果没有经过比较周密的设计，可能会出现死锁，而且，如果要更换策略的话，我们也需要知道<strong>何时需要介入，何时脱离紧急状态</strong>——毕竟本质上还是读者或者写者优先。</p>
<p>​		我用的方法不一定好，但是确实有效，就是<strong>调度时进行监测</strong>。如果有一方<strong>长期没有分配时间片</strong>（这实际上就是饥饿的特征），则阻止另一方正在休息的角色获得时间片。怎么验证算法的有效性呢？对于读者优先，我们可以将最大读者数设为1（很奇怪，这个数字大了的话反而容易让写者钻空子，也可能是我设置的数字有些问题），多跑几次进行比对。写者优先的话也类似，也可以设最大读者数为1。</p>
<p>​		然后是<strong>生产者消费者问题</strong>，不过这个题目出的更像<strong>苹果橘子问题</strong>——而且由于各个生产者消费者都只要知道自己的总量，所以实际上不考虑观察者的话并没有产生读写的交集区域，和传统的生产者消费者相比，还是有些简化的。</p>
<p>​		到此，Lab4的工作就完成了——这次实在是没什么可写的。</p>
<h1 id="Lab4回答试整理"><a href="#Lab4回答试整理" class="headerlink" title="Lab4回答试整理"></a><a id="chapter3">Lab4回答试整理</a></h1><p>​		这次的问答一些问题我心里也没啥底——即使这次我终于知道了一些学长的问答的答案，但是自己检索信息之后对于一些问题还是不能做到90%确定，尽管如此，我还是试着结合书上的内容和ORANGE’S的内容整理一下吧。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><a id="chapter3.1">进程</a></h2><p>第1题：进程是什么？ </p>
<p>答：<strong>《操作系统教程》</strong>上给出的定义是：进程是具有独立功能的程序在某个数据集合上的<strong>一次运行活动</strong>，是操作系统<strong>进行资源分配和保护</strong>的基本单位。</p>
<p>​		而<strong>ORANGE’S（第172页）</strong>进行了具体的描述：从宏观来看，进程有自己的功能，且受控于进程调度模块；从微观上来看，它可以利用系统的资源，有<strong>自己的代码和数据</strong>，同时有<strong>自己的堆栈</strong>。</p>
<h2 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a><a id="chapter3.2">进程表</a></h2><p>第2题：进程表是什么？</p>
<p>答（这里按照ORANGE’S<strong>最先给出的定义</strong>来解释）：进程表就是<strong>进程控制块</strong>。它用来存储进程的<strong>标识信息</strong>（唯一标识该进程的信息）、<strong>现场信息</strong>（处理器运行时的现场信息）和<strong>控制信息</strong>（与管理、调度相关的信息）。进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应。</p>
<p> （来自<strong>PPT</strong>）PCB是OS用于记录和刻画进程状态及环境信息的数据结构。借助PCB，OS可以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行。</p>
<h2 id="进程栈"><a href="#进程栈" class="headerlink" title="进程栈"></a><a id="chapter3.3">进程栈</a></h2><p>第3题:进程栈是什么？ </p>
<p>答(ORANGE’S<strong>第176页</strong>)：进程运行时自身的堆栈。</p>
<h2 id="esp的指向"><a href="#esp的指向" class="headerlink" title="esp的指向"></a><a id="chapter3.4">esp的指向</a></h2><p>第4题：当寄存器的值已经被保存到进程表内， esp 应该指向何处来避免破坏进程表的值？</p>
<p>答（ORANGE’S<strong>第176页</strong>）：指向内核栈。</p>
<h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a><a id="chapter3.5">tty</a></h2><p> 第5题：tty是什么？ </p>
<p>答：最早是电传打字机（teletype writer）。现在一般表示<strong>终端</strong>，是一种字符型设备。多个终端分占显存的不同位置（但共用显示器和键盘）。</p>
<h2 id="tty与显存"><a href="#tty与显存" class="headerlink" title="tty与显存"></a><a id="chapter3.6">tty与显存</a></h2><p>第6题：不同的tty为什么输出不同的画面在同⼀个显示器上？</p>
<p>答：不同的tty属领的console分别<strong>占有显存的不同位置</strong>，而<strong>通过端口0x3D4和0x3D5可以操纵显示器的寄存器</strong>的值从而<strong>指定从显存的某个位置开始显示</strong>，于是便可以在同一个显示器上输出不同的画面。</p>
<h2 id="tty任务的执行过程"><a href="#tty任务的执行过程" class="headerlink" title="tty任务的执行过程"></a><a id="chapter3.7">tty任务的执行过程</a></h2><p>第7题：解释 tty任务执行的过程？ </p>
<p>答：在tty任务<strong>完成初始化后</strong>，将通过一个循环轮询每一个tty。有两个阶段：</p>
<p>输入处理阶段：如果当前的控制台是轮询到的tty的控制台，他将会读取缓冲区并对得到的输入进行处理（比如处理<strong>内存中的键盘缓冲区</strong>的扫描码）。</p>
<p>输出处理阶段：如果缓冲区里有内容，则根据内容的情况写显存。</p>
<h2 id="tty结构体"><a href="#tty结构体" class="headerlink" title="tty结构体"></a><a id="chapter3.8">tty结构体</a></h2><p>第8题：tty结构体中大概包括哪些内容？ </p>
<p>（来自ORANGE’S的代码，解释也比较详尽了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_console</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TTY */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_tty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   u32    in_buf[TTY_IN_BYTES];  <span class="comment">/* TTY 输入缓冲区 */</span></span><br><span class="line">   u32*   p_inbuf_head;     <span class="comment">/* 指向缓冲区中下一个空闲位置 */</span></span><br><span class="line">   u32*   p_inbuf_tail;     <span class="comment">/* 指向键盘任务应处理的键值 */</span></span><br><span class="line">   <span class="type">int</span>    inbuf_count;      <span class="comment">/* 缓冲区中已经填充了多少 */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">s_console</span> * <span class="title">p_console</span>;</span></span><br><span class="line">&#125;TTY;</span><br></pre></td></tr></table></figure>

<h2 id="console结构体"><a href="#console结构体" class="headerlink" title="console结构体"></a><a id="chapter3.9">console结构体</a></h2><p>第9题：console结构体中大概包括哪些内容？</p>
<p>（来自ORANGE’S的代码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CONSOLE */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_console</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   current_start_addr;    <span class="comment">/* 当前显示到了什么位置    */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   original_addr;    <span class="comment">/* 当前控制台对应显存位置 */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   v_mem_limit;      <span class="comment">/* 当前控制台占的显存大小 */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   cursor;          <span class="comment">/* 当前光标位置 */</span></span><br><span class="line">&#125;CONSOLE;</span><br></pre></td></tr></table></figure>

<p>这里xl还在console里面加了<strong>一个8位的无符号成员</strong>color（应该是用来完成Lab3的颜色需求的），答的时候可以加上。</p>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a><a id="chapter3.10">时间片</a></h2><p>第10题：什么是时间片？ </p>
<p>答（<strong>《操作系统教程》第5版第105页</strong>）：调度程序把CPU分配给就绪队列首进程&#x2F;线程使用的<strong>规定的时间间隔</strong>。</p>
<p>来自<a target="_blank" rel="noopener" href="https://github.com/EagleBear2002/OS-Lab4">xl的blog</a>：时间片是分时操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。</p>
<h2 id="内核函数与系统调用"><a href="#内核函数与系统调用" class="headerlink" title="内核函数与系统调用"></a><a id="chapter3.11">内核函数与系统调用</a></h2><p>第11题：结合实验代码解释什么是内核函数？什么是系统调⽤？</p>
<p>答：内核函数就是只能在内核态下调用的例程或子程序，比如kliba.asm中的disable_int，关中断显然不是用户进程能直接调用的（实际上这个文件里的所有函数都可以看作是内核函数）。</p>
<p>​		而ORANGE’S中对于系统调用则有如下实现：</p>
<p>​		先通过汇编代码（syscall.asm）完成<strong>参数的保存与发出中断</strong>，跳入内核态。内核态下调用<strong>中断处理例程</strong>到IDT中找到对应的中断门，将控制权交给sys_call这一函数处理具体的系统调用型中断，该函数通过表驱动的方式再调用某一具体的系统调用函数（代码实现的位置因人而异）。系统调用为用户进程提供了一些系统功能的接口。</p>
<p><strong>To be continued…</strong></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogOfNoob.github.io/teawith/37800.html" title="secII淘金"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">secII淘金</div></div></a></div><div class="next-post pull-right"><a href="/blogOfNoob.github.io/teawith/19536.html" title="OSLab3随笔"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">OSLab3随笔</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/blogOfNoob.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mad Hatter</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blogOfNoob.github.io/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/blogOfNoob.github.io/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/blogOfNoob.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">萌新一枚，随手记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">搭建多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">从程序到进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">进程的变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%B7%B3%E5%87%BA%E5%86%85%E6%A0%B8"><span class="toc-number">1.2.1.</span> <span class="toc-text">先跳出内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.2.</span> <span class="toc-text">调度的发生时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E5%88%B0%E5%A4%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">从一到多</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%BC%A0%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="toc-number">2.</span> <span class="toc-text">扩张与陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9A%E5%B8%A6%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">增加系统调用：带参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E6%89%93%E5%8D%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">睡眠与打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">信号量的构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">增加进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">两个问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab4%E5%9B%9E%E7%AD%94%E8%AF%95%E6%95%B4%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">Lab4回答试整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">进程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">进程栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#esp%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">3.4.</span> <span class="toc-text">esp的指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tty"><span class="toc-number">3.5.</span> <span class="toc-text">tty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tty%E4%B8%8E%E6%98%BE%E5%AD%98"><span class="toc-number">3.6.</span> <span class="toc-text">tty与显存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tty%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">tty任务的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tty%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.8.</span> <span class="toc-text">tty结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.9.</span> <span class="toc-text">console结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">3.10.</span> <span class="toc-text">时间片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.11.</span> <span class="toc-text">内核函数与系统调用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/10840.html" title="OS复习">OS复习</a><time datetime="2023-06-05T15:35:32.000Z" title="Created 2023-06-05 23:35:32">2023-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/39322.html" title="一些手册的简单描述">一些手册的简单描述</a><time datetime="2023-05-31T15:29:17.000Z" title="Created 2023-05-31 23:29:17">2023-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/37800.html" title="secII淘金">secII淘金</a><time datetime="2023-05-30T15:42:27.000Z" title="Created 2023-05-30 23:42:27">2023-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/35878.html" title="OSLab4随笔">OSLab4随笔</a><time datetime="2023-05-22T15:14:32.000Z" title="Created 2023-05-22 23:14:32">2023-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/19536.html" title="OSLab3随笔">OSLab3随笔</a><time datetime="2023-05-07T07:43:33.000Z" title="Created 2023-05-07 15:43:33">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/blogOfNoob.github.io/img/path.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Mad Hatter</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blogOfNoob.github.io/js/utils.js"></script><script src="/blogOfNoob.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>