<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>下午六点的茶会</title>
  
  
  <link href="https://miceforrat.github.io/blogOfNoob.github.io/atom.xml" rel="self"/>
  
  <link href="https://miceforrat.github.io/blogOfNoob.github.io/"/>
  <updated>2023-05-31T15:30:14.702Z</updated>
  <id>https://miceforrat.github.io/blogOfNoob.github.io/</id>
  
  <author>
    <name>Mad Hatter</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些手册的简单描述</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/39322.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/39322.html</id>
    <published>2023-05-31T15:29:17.000Z</published>
    <updated>2023-05-31T15:30:14.702Z</updated>
    
    <content type="html"><![CDATA[<p>​这篇是研究一些secII的接口文档时顺手写写的。</p><p>​后面发现编译原理也得记下来。</p><h1 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a><a id="chapter1">Mapper</a></h1><p>这是<a href="https://mapstruct.org/documentation/stable/reference/html/">Mapper最新版的文档</a>里面的代码，但是我好像没找到类定义（这个原文档主打一个抽象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;manufacturer&quot;, source = &quot;make&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;seatCount&quot;, source = &quot;numberOfSeats&quot;)</span></span><br><span class="line">    CarDto <span class="title function_">carToCarDto</span><span class="params">(Car car)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;fullName&quot;, source = &quot;name&quot;)</span></span><br><span class="line">    PersonDto <span class="title function_">personToPersonDto</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Mapper的作用是在build时对于Mapper接口类自动生成其实现类。</p><h2 id="基本映射逻辑"><a href="#基本映射逻辑" class="headerlink" title="基本映射逻辑"></a><a id="chapter1.1">基本映射逻辑</a></h2><p>对于同名属性——直接映射（会自动进行类型转化）。</p><p>对于目标类中目标属性名缺失的属性——不映射（或者进行特殊指定）。</p><p>特殊指定的方法，设定target和source：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping(target = &quot;manufacturer&quot;, source = &quot;make&quot;)</span></span><br><span class="line"><span class="meta">@Mapping(target = &quot;seatCount&quot;, source = &quot;numberOfSeats&quot;)</span></span><br><span class="line">CarDto <span class="title function_">carToCarDto</span><span class="params">(Car car)</span>;</span><br></pre></td></tr></table></figure><p>target和source后面跟的都是属性的名字</p><p>在build时，将会自动生成实现的代码。生成实现代码时，不仅仅有我们在接口里定义的函数，还会根据实际情况生成函数。比如假设我们的car里面有一个Engine类成员，carDto里面有一个engineDto类成员，那么生成的实现类会有一个函数<strong>engineToEngineDto</strong>。当然和编译原理的类似，不建议修改这些自动生成的<strong>实现类</strong>，因为他们build的时候又会被替换。</p><p>@Mapping有一些特殊的用法，比如dto转entity，不过这次用不到。</p><h2 id="DIY映射逻辑"><a href="#DIY映射逻辑" class="headerlink" title="DIY映射逻辑"></a><a id="chapter1.2">DIY映射逻辑</a></h2><p>Java里面，使用<strong>default关键字可以修饰接口类里面的具体方法</strong>（我去年学java的时候在干什么^v^!），这样我们就可以自己写逻辑，而不是交给他们去生成实现。</p><h2 id="支持多参映射"><a href="#支持多参映射" class="headerlink" title="支持多参映射"></a><a id="chapter1.3">支持多参映射</a></h2><p>Mapper支持传入多个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">myMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;name&quot;, source = &quot;s1.name&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;level&quot;, source = &quot;s2.level&quot;)</span></span><br><span class="line">    TargetDto <span class="title function_">s1AndS2ToTargetDto</span><span class="params">(SourceOne s1,  SourceTwo s2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为映射的时候是按照属性名进行映射，所以如果<strong>两个来源出现了同名属性</strong>，会有报错，对此，可以通过@Mapping显式地指出应该映射到哪里来解决报错。</p><p>当然，映射中也可以<strong>直接把一个参数映射到一个属性</strong>。</p><p>当我们指定target&#x3D;’.’时，则转化所有属性。出现冲突时，仍需要<strong>显式地</strong>解决。</p><p>别的暂时好像不需要，Hibernate的东西可以依葫芦画瓢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	这篇是研究一些secII的接口文档时顺手写写的。&lt;/p&gt;
&lt;p&gt;​	后面发现编译原理也得记下来。&lt;/p&gt;
&lt;h1 id=&quot;Mapper&quot;&gt;&lt;a href=&quot;#Mapper&quot; class=&quot;headerlink&quot; title=&quot;Mapper&quot;&gt;&lt;/a&gt;&lt;a id=&quot;cha</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>secII淘金</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/37800.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/37800.html</id>
    <published>2023-05-30T15:42:27.000Z</published>
    <updated>2023-05-31T05:25:56.065Z</updated>
    
    <content type="html"><![CDATA[<p><a id="chapter1">01-软件工程基础</a></p><p>软件定义的变化（这玩意应该不考吧）</p><p><strong>软件工程的定义</strong>：</p><p>[IEEE610.12-1990]  （1）The application of a systematic, disciplined, quantifiable approach  to the development, operation, and maintenance of software; that is,  the application of engineering to software.  （2）The study of approaches as in （1）</p><p>中文：</p><p>（1)应用系统的、规范的、可量化的方法，来开发、运行和维护软件，即将工程应用到<br>软件。<br>(2)对(1)中各种方法的研究。</p><p><a id="chapter2">02-软件工程的发展</a></p><p>软件工程的三个环境因素：现实问题、抽象软件实体（计算机科学）、虚拟计算机（硬件和系统软件）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a id=&quot;chapter1&quot;&gt;01-软件工程基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;软件定义的变化（这玩意应该不考吧）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件工程的定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;[IEEE610.12-1990]  （1）The application of </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OSLab4随笔</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/35878.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/35878.html</id>
    <published>2023-05-22T15:14:32.000Z</published>
    <updated>2023-05-29T01:59:37.341Z</updated>
    
    <content type="html"><![CDATA[<p>​如题，现在终于有时间来整理一下Lab4的内容了。不过Lab4的内容着实不多，而且相关的伪代码&#x2F;代码要么ORANGE’S上面有，要么《操作系统教程》上面有(PV操作的伪代码)，要么助教补充的细节里面有，要么葛老师的PPT里有（读者优先），所以实现起来应该还好。但是，就算这样，我们还是得知道我们手头的东西里面有什么。</p><p>​我看了下提问好像还会问到第7章相关的内容，有点难绷。</p><p>​第三部分按照顺序整理了问答。</p><p><a href="#chapter1">1. 搭建多进程</a></p><p><a href="#chapter1.1">1.1 从程序到进程</a></p><p><a href="#chapter1.2">1.2 进程的变换</a></p><p><a href="#chapter1.2.1">1.2.1 先跳出内核</a></p><p><a href="#chapter1.2.2">1.2.2调度的发生时机</a></p><p><a href="#chapter1.3">1.3 系统调用</a></p><p><a href="#chapter2">2. 扩张与陷阱</a></p><p><a href="#chapter2.1">2.1 增加系统调用：带参数</a></p><p><a href="#chapter2.1.1">2.1.1 睡眠与打印</a></p><p><a href="#chapter2.1.2">2.1.2 信号量的构造</a></p><p><a href="#chapter2.2">2.2 增加进程</a></p><p><a href="#chapter2.3">2.3 两个问题</a></p><p><a href="#chapter3">3 OSLab4问答试整理</a></p><p><a href="#chapter3.1">3.1 进程</a></p><p><a href="#chapter3.2">3.2 进程表</a></p><p><a href="#chapter3.3">3.3 进程栈</a></p><p><a href="#chapter3.4">3.4 esp的指向</a></p><p><a href="#chapter3.5">3.5 tty</a></p><p><a href="#chapter3.6">3.6 tty与显存</a></p><p><a href="#chapter3.7">3.7 tty任务的执行过程</a></p><p><a href="#chapter3.8">3.8 tty结构体</a></p><p><a href="#chapter3.9">3.9 console结构体</a></p><p><a href="#chapter3.10">3.10 时间片</a></p><p><a href="#chapter3.11">3.11 内核函数与系统调用</a></p><h1 id="搭建多进程"><a href="#搭建多进程" class="headerlink" title="搭建多进程"></a><a id="chapter1">搭建多进程</a></h1><p>​这里我们需要从第6章开始来继续读书。在第5章（见Lab3）中，我们已经实现了GDT和IDT，这样可以支持一些基本的保护模式寻址和中断的行为了。然而，要进行这一次的实验，<strong>进程</strong>的实现显然是必不可少的。就跟着书上的脚步，来搭建出一个个进程吧。</p><h2 id="从程序到进程"><a href="#从程序到进程" class="headerlink" title="从程序到进程"></a><a id="chapter1.1">从程序到进程</a></h2><p>​快到期末了，这里也顺便整理一下各种各样的思路，来探讨一下，进程到底为何存在？</p><p>​我们的程序其实有很多的“依赖”，比如说一些特定的程序可能需要<strong>栈</strong>，再比如我们的程序也有自身所需要的<strong>数据</strong>，对于一个程序而言，这些事物的存在似乎是天经地义的。如果我们足够耐心，我们也可以等工作一件一件去做。可是人终究是会追求一些更高的东西的——比如更高的运行效率，更短的<strong>总运行时间</strong>。纯粹串行执行是有瓶颈的——比如IO外设的数据传输速度会让执行这个程序的处理器花费相当的时间去等它完成I&#x2F;O。所以我们需要在这个时候把处理器让出来给其他的程序。然而，踢掉一个程序是很容易的，可是怎么把他加回来呢？程序和程序之间的数据和堆栈可能是完全没有交集的，我们该怎么记住上一次，甚至前面几次占有处理器的程序呢？所以，我们需要一个容器，<strong>至少</strong>能来保存这些必要的信息。基于这种想法，便能想到所谓的<strong>进程</strong>——从实现上来说，它本质上也不过是一种<strong>保存了一些关键信息的数据结构</strong>罢了。</p><p>​另一个问题是，进程调度何时发生？</p><p>​一个容易想到的情况就是，当进程实在跑不下去的时候，他自然就需要让出处理器了。这时我们便可以剥夺这个进程的处理器资源，交给一个其他的进程。书上考虑了一种在实现上更简单的情况——也就是在时钟中断时进行调度。</p><p>​前面我们并没有讲清楚，在进程切换的时候，应当保存什么，因为这部分最好合着一些实际的内容一起讲。</p><p>​这个问题的等价提法是，列出一个程序需求的所有内容，然后找出在其他程序运行时可能修改的部分。</p><p>​我们可以先假定内存足够大，于是可以认为各个程序存储在内存中的数据和代码是互不干涉的。堆栈说来神秘，实际上他也<strong>不过是一块内存区域</strong>——只不过我们可以通过ss和esp特定地拿到它的位置，就像eip和cs一样。所以，我们实际上只需要保存<strong>这些区域在哪里</strong>。同时，我们可能还有一些临时计算的值需要进行保存。简单来说，我们需要保存的是寄存器的值。</p><p>​那么怎么保存呢？我们上面说过，应该有一个单独的数据结构来存储需要存储的关键信息。所以我们要做的无非是<strong>将寄存器中的数据传送到某个特定的内存区域</strong>。然而，我们完全没有必要自己去写一套传送的方法。在上一段中，我提过，堆栈不过是一块内存区域，于是我们只需要让存储进程的相关信息的数据结构的区域<strong>被认为是一块堆栈</strong>——也就是让esp指向这个区域，然后我们就可以<strong>用push和pop指令</strong>进行这块内存和寄存器的信息交换——INTEL甚至提供了<strong>pushad</strong>这个指令（但是段寄存器不会入栈），来把所有寄存器的值都<strong>依据一个特定的顺序</strong>保存进栈里。</p><p>​这一块区域也就属于我们OS课上教的<strong>进程控制块</strong>，下面的讲述中，尽管和ORANGE’S不同，我还是用进程控制块而不是<strong>进程表</strong>这个概念（ORANGE’S<strong>在这里</strong>对进程表的说法是和进程控制块等价，后面还出现了一些可能矛盾的表述；而从我查到的情况来看，一些出现进程表的表述会用<strong>进程表项</strong>来表示进程控制块）。</p><p>​当然，由于一些概念尚未讲到，所以这里还是有可能遗漏一些保存内容的，不过下面也会进行补充。</p><h2 id="进程的变换"><a href="#进程的变换" class="headerlink" title="进程的变换"></a><a id="chapter1.2">进程的变换</a></h2><p>​这一部分的任务仍然并不单一，我们可以再想一想，先从哪一步去入手。</p><p>​既然我们有了进程表，所以我们只需要<strong>从某个指定的进程控制块里pop数据到寄存器</strong>，就可以设置上下文，从未让处理器运行对应的进程。这些内容显然不可能交给用户进程去完成，只能给内核去完成。所以书上先实现了从用户进程跳入内核，再从内核跳回用户进程的操作。</p><h3 id="先跳出内核"><a href="#先跳出内核" class="headerlink" title="先跳出内核"></a><a id="chapter1.2.1">先跳出内核</a></h3><p>​一开始我们是在内核态的，所以不妨先从<strong>ring 0</strong>跳到用户进程的特权级，同时这一个从无到有的过程也能让我们更加明确后续进行进程切换的时候需要设置哪些东西。</p><p>​在一切操作之前，我们不妨先给自己减减负，比如允许我们用C语言编写多数代码，于是我们可以在kernel.asm中找到下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp kernel_main</span><br></pre></td></tr></table></figure><p>​这里的kernel_main函数正是在main.c中，我们可以在这个函数中完成一些数据初始化的事情。</p><p>​从Lab3的讲述中，我们知道，可以在栈中预先压入对应的值（ss,esp,eflags,cs,eip），调用<strong>iretd</strong>时，就会自动将栈中这些值pop入对应的寄存器，从而可以指定接下来执行的代码段和对应的堆栈段，同时设置相应的标志寄存器的情况。</p><p>​不过，我们尚有一些其他的情况要去考虑。虽然我们上文认为不同程序的内存上是互不干涉的，但这实际上有一个前提条件，那就是一个进程不应该歪打正着地<strong>寻址到属于另一个进程的地址</strong>，所以，对应的段描述符<strong>不应该被放在GDT里</strong>——这些谁都能碰得到，保不齐哪个进程脑洞大开一下就接触到另一个进程的内容了呢？所以，我们应该引入<strong>LDT（局部描述符表）</strong>。LDT的寻址方式我在Lab2的问题回答当中已然写过，在这就不再重复了。这一种寻址方式使得我们可以通过<strong>LDTR</strong>来选择使用哪一个LDT，而用户进程不应该能够自由地设置LDTR。不过这又引出了一些新的问题，比如LDT放哪，LDTR的值又应该放哪呢？</p><p>​以ORANGE’S的实现为例，LDT就是放在<strong>进程的结构体</strong>（<strong>s_proc</strong>）里边的。同时，考虑到对于<strong>同一个进程</strong>，<strong>LDTR是不变的</strong>，而且pushad也不会将LDTR中的选择子推入栈中，所以我们单独开一个成员来存这个<strong>确定的选择子</strong>即可。同时，我们还要在GDT中加入LDT的段描述符以供查询。</p><p>​无论是进程表的初始化还是ldt的设置，我们都可以在main.c中的<strong>kernel_main</strong>函数中找到。其中有一些位运算的内容，如果想要深究，可以将相关寄存器里应该存的值和初始化赋值时位运算的结果进行一下比对，这样可以进一步理解相关的内容。</p><p>​考虑到我们会有多个进程，所以我们需要一个特别的数组来存储我们的进程们（书上也叫他进程表，这里为了区别以及考虑到一致性的问题，我下面的叙述会用<strong>进程列表</strong>来加以区别，尽管可能并不存在这样一个名词），这样一个列表在global.c中，我们可以通过修改<strong>proc.h中的NR_TASKS</strong>的值以及在数组初始化时增加一个成员来增加新的进程——当然，新的工作可能并不止这些，我后文还会总结。</p><p>​除了kernel_main中有初始化工作外，<strong>protect.c中的init_prot函数</strong>也做了一部分的工作，具体来说，是增加GDT中的相关描述符。</p><p>​最后，考虑到从用户特权级进入内核特权级需要用到TSS，这里需要再初始化一下TSS——是的，第五章的代码甚至都没有做这个工作。除此之外，还需要在GDT中加入一个TTS的描述符。</p><p>​做完信息初始化后，我们可别忘了，即使是kernel_main也还是在内核态下的，我们要通过iretd指令跳到用户态。于是这里ORANGE又写了一个汇编函数<strong>restart，在kernel.asm中</strong>。它的工作是将必要的寄存器的值（通过从栈中弹出）进行设置从而确保后续的正确运行。因此，一上来就将esp指向了<strong>p_proc_ready</strong>，等价于将要运行的程序的程序控制块。</p><p>​这其中有这么四条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movesp, [p_proc_ready]</span><br><span class="line">lldt[esp + P_LDT_SEL] </span><br><span class="line">lea eax, [esp + P_STACKTOP]</span><br><span class="line">movdword [tss + TSS3_S_SP0], eax</span><br></pre></td></tr></table></figure><p>​这里的lea是<strong>load effective address</strong>，装入有效地址的意思。他将esp+P_STACKTOP对应得到的值作为地址装入了eax。</p><p>​将这四条连起来看，我们可以简单地认为是将esp指向下一个要运行的进程的进程控制块，然后后面的esp+P_STACK_TOP需要结合proc.h中的s_proc定义来看，其值是<strong>p_proc_ready的reg成员的末地址</strong>。后面有一个宏定义TSS3_S_SP0，这个意思是esp 0的偏移，所以就是将p_proc_ready的reg成员的末地址（栈是<strong>从高往低</strong>生长的）存到<strong>TSS的esp 0</strong>中，这样，若要从用户进程进入内核态，栈指针就会先指向这里，将堆栈段寄存器、栈指针寄存器、代码段寄存器、指令指针寄存器等的值压栈（这是call这个指令的功能）后，就可以进一步pushad保存其他寄存器的值。</p><p>​到此为止，可以从内核态跳入用户态了。</p><h3 id="调度的发生时机"><a href="#调度的发生时机" class="headerlink" title="调度的发生时机"></a><a id="chapter1.2.2">调度的发生时机</a></h3><p>​那么用户态什么情况下会跳回内核态呢？比如<strong>中断发生</strong>的时候，用户程序将不得不把控制权交给内核。</p><p>​自然地，书上开始<strong>扩充时钟中断</strong>的内容。</p><p>​为了保证能<strong>后面能回到进入内核态的用户程序的正确位置</strong>，我们需要<strong>保存现场</strong>。由于上个部分中，我们已经设置过TSS的esp 0，且call的时候已经做了一定的处理，所以此时我们跳到了进程控制块的起始位置，从而可以放心地压入一些寄存器的值。自然，返回的时候我们还需要通过从进程控制块中弹出值来恢复这些寄存器的值。同时。</p><p>​然而，一个值得注意的点是，我们需要在保存现场之后立即<strong>切换到内核栈</strong>，不然一些内核态下的堆栈操作可能会破坏现场。同时，在准备返回时，我们还要让堆栈回到将要运行的进程控制块所在处（p_proc_ready），然后弹出相关的值到寄存器中。</p><p>​这里实际上就有我们可以操作的点了。我们实际上只要在内核态时<strong>修改p_proc_ready</strong>，就可以<strong>返回到不同的用户进程</strong>，从而完成了进程切换。</p><p>​还要注意一个可能遗漏的地方，那就是<strong>TSS的esp 0</strong>，这是每次切换到内核态时我们保存相关寄存器的位置。如果我们切换了进程，却没有修改这个esp 0，下次进入内核态时，就会<strong>污染其他进程的已经保存的寄存器</strong>。所以我们在从内核态返回之前，必须要再次设置TSS的esp 0。同样的，像<strong>ldtr中的选择子</strong>也需要在中断处理时进行替换。</p><p>​最后，代码还进行了一些中断重入的处理。具体来说，就是中断重入不再切换栈等。</p><p>​到这里，基本上<strong>一个进程</strong>在<strong>内核间的反复横跳</strong>已经完成了，后续要做的就是增加新的进程，以及封装进程调度的代码了。</p><p>​</p><h3 id="从一到多"><a href="#从一到多" class="headerlink" title="从一到多"></a><a id="chapter1.2.3">从一到多</a></h3><p>​接下来应当再增加一个进程，不过具体怎么加我后文还会再具体写出来。</p><p>​在这里，作者需要做的是将原来对一个进程的初始化一般化。比如，作者用了一个数组来存储进程所执行的<strong>任务</strong>（相关的定义在global.h中，而数组内容的填充在global.c中），在初始化进程控制块的时候进行一定的搬运即可。</p><p>​同样的，我们在init_prot这个函数中也要将<strong>LDT的描述符的初始化</strong>循环化。</p><p>​至此，作者加入了一个clock_handler函数（clock.c），在汇编代码中调用之，然后在c代码中替换了proc_ready为另一个进程。</p><p>​后面就是一些中断处理代码的优雅化一点的重构了。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><a id="chapter1.3">系统调用</a></h2><p>​这次Lab还有一个重头戏，那就是系统调用。</p><p>​其实系统调用不过就是把一件事情交给系统去做，用户进程只要知道结果就可以了。</p><p>​而在ORANGE至此为止的实现中，用户进程何时可以跳入内核态呢？<strong>中断的时候</strong>。</p><p>​所以我们只需要将系统调用作为一种分配了特定中断向量号的特殊的中断就好了。这也使得系统调用的初步处理需要在<strong>汇编</strong>中进行（但是汇编很明显容易犯各种各样的错误）。而对于不同类型的系统调用，我们可以通过<strong>修改eax寄存器的值</strong>来加以设定。如果有参数，我们还要用其他寄存器存储参数（后文会写增加系统调用的步骤和坑）。</p><p>​在做完参数设置之后，我们就可以把工作交给中断处理例程了。</p><p>​中断处理例程会按照情况进一步调用不同的中断处理函数，于是接下来又到需要我们发挥的地方了，当中断处理例程把控制权交给我们的<strong>系统调用处理函数</strong>后，我们可以用eax中的值，通过<strong>表驱动</strong>的方式，调用不同的例程——在调用例程之前需要先把参数<strong>按顺序从寄存器中压入栈中</strong>（至少32位是这样的）。</p><p>​最后，系统调用表结合<strong>系统调用号</strong>（eax中的值）将会指向我们写好的相关函数，完成系统调用。</p><h1 id="扩张与陷阱"><a href="#扩张与陷阱" class="headerlink" title="扩张与陷阱"></a><a id="chapter2">扩张与陷阱</a></h1><p>​其实第6章还有一部分关于进程调度的内容。不过这部分做的事情主要就是把调度功能通过<strong>schedule函数</strong>封装起来，放置在了<strong>proc.c</strong>里面。</p><p>​我写的时候是按照要求用的第6章的代码（不过我建议用第7章写，主要是第7章提供了非常方便的输出机制）。</p><p>​由于这本书的内容包括一些前辈的遗产已经比较老了，照搬代码还是有可能出现一些问题，所以这里我还会整理一下一些内容添加的过程。</p><h2 id="增加系统调用：带参数"><a href="#增加系统调用：带参数" class="headerlink" title="增加系统调用：带参数"></a><a id="chapter2.1">增加系统调用：带参数</a></h2><p>​如果只是抽象地讲的话，整个过程还是不太好理解，不如拿一个具体的函数来做示范——比如睡眠函数。当然这部分书上也有阐释（在第7章，<strong>294页开始</strong>，简单的版本在第295页的表7.6），但是中间可能还是有些<strong>啸问题</strong>。</p><h3 id="睡眠与打印"><a href="#睡眠与打印" class="headerlink" title="睡眠与打印"></a><a id="chapter2.1.1">睡眠与打印</a></h3><p>​如果我们要加入一个sleep系统调用（参数为时间），根据系统调用的处理过程，我们需要做下列事情：</p><p>​第一阶段：<strong>sleep函数调用阶段</strong>。为了保证这个阶段正常进行，我们需要在proto.h中加入一个函数定义，比如说是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> milli_time)</span>;</span><br></pre></td></tr></table></figure><p>​然后我们要去syscall.asm中加入这么几条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_NR_sleepequ1;这个看情况，如果之前有别的系统调用号，这个数字就顺延递增</span><br><span class="line"></span><br><span class="line">global sleep;让外面的代码文件知道有sleep这么个函数</span><br></pre></td></tr></table></figure><p>​接下来我们还是在syscall.asm中<strong>加入sleep的函数体</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sleep:</span><br><span class="line">    mov eax, _NR_sleep</span><br><span class="line">    push ebx</span><br><span class="line">    mov ebx, [esp+8]</span><br><span class="line">    int INT_VECTOR_SYS_CALL</span><br><span class="line">    pop ebx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>​这里注意和书上不同的是，我们不能直接修改ebx的值，不然后续的寻址可能产生其他的一些问题，我们需要通过栈保存相应寄存器的值，中断之后再pop出来。</p><p>​第二阶段：<strong>中断处理例程阶段</strong>。这一部分没什么要改的。</p><p>​第三阶段：<strong>特定中断（系统调用类中断）处理阶段</strong>。这一部分我们需要注意，如果有参数的话应当<strong>按照顺序压入参数</strong>，这需要修改<strong>kernel.asm中的sys_call函数</strong>。可以注意到，这个函数中原原本本有这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    [sys_call_table + eax * 4]</span><br></pre></td></tr></table></figure><p>​所以我们需要去找到<strong>sys_call_table</strong>，它的初始化在<strong>global.c</strong>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC  system_call       sys_call_table[NR_SYS_CALL] = &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>​在这里，我们需要再<strong>在proto.h中定义函数sys_sleep</strong>，将他作为一个成员加到<strong>sys_call_table</strong>中，同时将<strong>NR_SYS_CALL的值加一</strong>（在const.h中）。</p><p>​第四阶段：<strong>特定系统调用（比如sys_sleep）处理阶段</strong>。这一阶段我们只需要编写函数实现睡眠即可。</p><p>​类似地，我们还可以写一下打印的实现。如果是从第7章的代码出发，就比较轻松了。我们可以直接<strong>调out_char进行打印</strong>。如果在第6章，我们还得自己写个写显存的简单机制。不建议调用disp_str，作为一个复杂函数，它直接操作了寄存器，可能带来一些意想不到的结果（甚至有可能是不多写点东西不会出现的结果）。</p><h3 id="信号量的构造"><a href="#信号量的构造" class="headerlink" title="信号量的构造"></a><a id="chapter2.1.2">信号量的构造</a></h3><p>​还有两个系统调用：<strong>信号量的PV操作</strong>需要实现。</p><p>​这两个的伪代码，其实<strong>《操作系统教程》</strong>中也给出了，现抄录如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore s)</span>&#123;</span><br><span class="line">    s.value--;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(s.<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore s)</span>&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(s.<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​相关的解释无论是教材上还是jyy的视频里还是葛老师的课上或是PPT上都给出了。简单地说，value成员体现了信号量的供求情况。在P操作之后，value成员仍然大于0说明供大于求，资源可以被直接获得；如果value成员小于0，则说明<strong>供不应求</strong>，执行P操作的进程应该开始等待资源（进入睡眠，将<strong>不具备获得时间片的资格</strong>）。类似地，V操作之后，如果value成员小于等于0，则说明<strong>还有人正在等待资源</strong>，应当唤醒一个进程，注意这里<strong>只是唤醒</strong>，而不是强行把资源塞给它让它运行。如果value大于0，则说明甚至还有资源结余，即无进程处于等待状态。</p><p>​具体实现的时候需要注意，当唤醒（释放）一个节点（如果偷懒直接用s_proc作为结点）时，应当将其next指针清0，防止后续P操作添加节点到末尾时出现问题。</p><p>​完成这两个系统调用后，我们实际上具备了<strong>构造一个原子化的密室</strong>的条件，这将有助于我们后面的实现。</p><h2 id="增加进程"><a href="#增加进程" class="headerlink" title="增加进程"></a><a id="chapter2.2">增加进程</a></h2><p>​下一步要做的事情是增加进程，由于我是基于第六章的代码进行的功能书写，所以我这里给出的方法不一定适合基于第7章的功能书写。我后面问了别人可能顺便写在下面。（问了下whm，好像没什么区别）。</p><p>​这个方法来自于ORANGE<strong>第207页</strong>。考虑到版本差别，现也用我自己的逻辑叙述如下：</p><p>​还是从程序所需的内容入手。代码段和堆栈段通过<strong>将函数加入TASK_TABLE</strong>的方式即可解决。这需要我们<strong>在proto.h中定义一个函数</strong>，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">observer</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>​然后我们找到TASK_TABLE：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC  TASK   task_table[NR_TASKS] = &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>​我们需要把宏<strong>NR_TASKS</strong>加1，同时复制一份表项加进去。</p><p>​由于表项中需要一个新的堆栈段的size，于是我们<strong>重新去proc.h中定义一个</strong>，再修改<strong>STACK_SIZE_TOTAL</strong>的值。</p><p>​到这里为止，我们已经加入了一个进程。接下来，只要<strong>完善进程的函数体</strong>即可。</p><h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a><a id="chapter2.3">两个问题</a></h2><p>​上面两个技术算是比较基本的。而对于这次需要实现的两个经典问题，我打算只简单讲一下——这实在是因为讲述这些经典问题的<strong>互联网资源</strong>实在是太多了。</p><p>​首先是<strong>读者写者问题</strong>。读者群体和写者之间需要有一把互斥锁。这个互斥锁应该初值为1，从而保证在<strong>有读者或者有写者的时候</strong>，另一方无法进行操作。由于<strong>不允许多个写者一起写</strong>，所以这个互斥锁可以顺带用来作为写者和写者之间的互斥锁。写者获取和释放锁的情况是简单的。但是对于读者来说，必须限制<strong>第一个进入临界区的读者才能获取写锁</strong>，不然其他读者尝试获取锁时也会被拒之门外，所以我们需要一个计数<strong>来计算临界区内的读者数</strong>。显然，这个值的<strong>增减和判断应当是原子化的</strong>，否则可能出现两个读者增加计数后使count为2，从而没有一个读者想要主动获得写锁。如果存在读者数量，我们还要加一把数量锁。</p><p>​伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">(<span class="type">int</span> work_ticks, <span class="type">int</span> rest_ticks)</span> &#123;</span><br><span class="line">P(&amp;reader_register); <span class="comment">//读者进入“读者信息登记区域”，可以认为这里有一道门</span></span><br><span class="line">    reader_cnt++; <span class="comment">//读者将读者数+1</span></span><br><span class="line"><span class="keyword">if</span> (reader_cnt == <span class="number">1</span>)&#123;</span><br><span class="line">P(&amp;writer_lock); </span><br><span class="line">    &#125;<span class="comment">//如果这是第一个读者，他应该获取写锁</span></span><br><span class="line">V(&amp;reader_register);<span class="comment">//读者离开这个区域，唤醒其他等待注册的读者</span></span><br><span class="line"></span><br><span class="line">P(&amp;reader_cnt_lock);<span class="comment">//读者进入工作区，工作区内的最大读者数量取决于初值</span></span><br><span class="line">do_read(work_ticks);<span class="comment">//工作</span></span><br><span class="line">V(&amp;reader_cnt_lock);<span class="comment">//读者离开工作区，如果有等待的读者，将他唤醒</span></span><br><span class="line"></span><br><span class="line">P(&amp;reader_register);<span class="comment">//读者进入“读者信息登记区域”，准备登记退出。</span></span><br><span class="line">    reader_cnt--;<span class="comment">//这个读者将读者数-1</span></span><br><span class="line"><span class="keyword">if</span> (reader_cnt == <span class="number">0</span>)&#123;</span><br><span class="line">V(&amp;writer_lock); </span><br><span class="line">    &#125;<span class="comment">//如果他是工作区域内的最后一个离开的读者，他应该释放写锁。</span></span><br><span class="line">V(&amp;reader_register);</span><br><span class="line">    </span><br><span class="line">    rest(rest_ticks);<span class="comment">//休息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">(<span class="type">int</span> work_ticks, <span class="type">int</span> rest_ticks)</span> &#123;</span><br><span class="line">P(&amp;writer_lock);<span class="comment">//获取写锁</span></span><br><span class="line">do_write(work_ticks);</span><br><span class="line">V(&amp;writer_lock);<span class="comment">//释放写锁</span></span><br><span class="line">rest(rest_ticks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这个结构算是比较烂大街了。而且，根据这个需求实现出来的读者写者问题的模拟天然地具有<strong>读者优先</strong>的性质。</p><p>​那写者优先怎么实现呢？上述的方法出现的最大问题是，对于读者的登记，几乎没有限制——只要读者能把写锁牢牢地握在手中，很有可能源源不断地进入工作区。而且读者和另一个写者如果要<strong>等候写锁</strong>，也纯是看先来后到，并不能确保写者对写锁的优势。</p><p>​所以，可以在读者的注册区域外再套一把锁，这把锁<strong>将握在写者们的手中</strong>。同时由于需要<strong>对写者实现和读者类似的计数工作</strong>，所以我们还需要<strong>给写者的“注册”加一把互斥锁</strong>。</p><p>​这些烂大街的工作到处都能查得到，我就不赘述了。这里讨论一下怎么防止饥饿。</p><p>​窃以为用公平读写应该是不行的——<strong>临时</strong>更换一种策略的话，如果没有经过比较周密的设计，可能会出现死锁，而且，如果要更换策略的话，我们也需要知道<strong>何时需要介入，何时脱离紧急状态</strong>——毕竟本质上还是读者或者写者优先。</p><p>​我用的方法不一定好，但是确实有效，就是<strong>调度时进行监测</strong>。如果有一方<strong>长期没有分配时间片</strong>（这实际上就是饥饿的特征），则阻止另一方正在休息的角色获得时间片。怎么验证算法的有效性呢？对于读者优先，我们可以将最大读者数设为1（很奇怪，这个数字大了的话反而容易让写者钻空子，也可能是我设置的数字有些问题），多跑几次进行比对。写者优先的话也类似，也可以设最大读者数为1。</p><p>​然后是<strong>生产者消费者问题</strong>，不过这个题目出的更像<strong>苹果橘子问题</strong>——而且由于各个生产者消费者都只要知道自己的总量，所以实际上不考虑观察者的话并没有产生读写的交集区域，和传统的生产者消费者相比，还是有些简化的。</p><p>​到此，Lab4的工作就完成了——这次实在是没什么可写的。</p><h1 id="Lab4回答试整理"><a href="#Lab4回答试整理" class="headerlink" title="Lab4回答试整理"></a><a id="chapter3">Lab4回答试整理</a></h1><p>​这次的问答一些问题我心里也没啥底——即使这次我终于知道了一些学长的问答的答案，但是自己检索信息之后对于一些问题还是不能做到90%确定，尽管如此，我还是试着结合书上的内容和ORANGE’S的内容整理一下吧。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><a id="chapter3.1">进程</a></h2><p>第1题：进程是什么？ </p><p>答：<strong>《操作系统教程》</strong>上给出的定义是：进程是具有独立功能的程序在某个数据集合上的<strong>一次运行活动</strong>，是操作系统<strong>进行资源分配和保护</strong>的基本单位。</p><p>​而<strong>ORANGE’S（第172页）</strong>进行了具体的描述：从宏观来看，进程有自己的功能，且受控于进程调度模块；从微观上来看，它可以利用系统的资源，有<strong>自己的代码和数据</strong>，同时有<strong>自己的堆栈</strong>。</p><h2 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a><a id="chapter3.2">进程表</a></h2><p>第2题：进程表是什么？</p><p>答（这里按照ORANGE’S<strong>最先给出的定义</strong>来解释）：进程表就是<strong>进程控制块</strong>。它用来存储进程的<strong>标识信息</strong>（唯一标识该进程的信息）、<strong>现场信息</strong>（处理器运行时的现场信息）和<strong>控制信息</strong>（与管理、调度相关的信息）。进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应。</p><p> （来自<strong>PPT</strong>）PCB是OS用于记录和刻画进程状态及环境信息的数据结构。借助PCB，OS可以全面管理进程的物理实体，刻画进程的执行现状，控制进程的执行。</p><h2 id="进程栈"><a href="#进程栈" class="headerlink" title="进程栈"></a><a id="chapter3.3">进程栈</a></h2><p>第3题:进程栈是什么？ </p><p>答(ORANGE’S<strong>第176页</strong>)：进程运行时自身的堆栈。</p><h2 id="esp的指向"><a href="#esp的指向" class="headerlink" title="esp的指向"></a><a id="chapter3.4">esp的指向</a></h2><p>第4题：当寄存器的值已经被保存到进程表内， esp 应该指向何处来避免破坏进程表的值？</p><p>答（ORANGE’S<strong>第176页</strong>）：指向内核栈。</p><h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a><a id="chapter3.5">tty</a></h2><p> 第5题：tty是什么？ </p><p>答：最早是电传打字机（teletype writer）。现在一般表示<strong>终端</strong>，是一种字符型设备。多个终端分占显存的不同位置（但共用显示器和键盘）。</p><h2 id="tty与显存"><a href="#tty与显存" class="headerlink" title="tty与显存"></a><a id="chapter3.6">tty与显存</a></h2><p>第6题：不同的tty为什么输出不同的画面在同⼀个显示器上？</p><p>答：不同的tty属领的console分别<strong>占有显存的不同位置</strong>，而<strong>通过端口0x3D4和0x3D5可以操纵显示器的寄存器</strong>的值从而<strong>指定从显存的某个位置开始显示</strong>，于是便可以在同一个显示器上输出不同的画面。</p><h2 id="tty任务的执行过程"><a href="#tty任务的执行过程" class="headerlink" title="tty任务的执行过程"></a><a id="chapter3.7">tty任务的执行过程</a></h2><p>第7题：解释 tty任务执行的过程？ </p><p>答：在tty任务<strong>完成初始化后</strong>，将通过一个循环轮询每一个tty。有两个阶段：</p><p>输入处理阶段：如果当前的控制台是轮询到的tty的控制台，他将会读取缓冲区并对得到的输入进行处理（比如处理<strong>内存中的键盘缓冲区</strong>的扫描码）。</p><p>输出处理阶段：如果缓冲区里有内容，则根据内容的情况写显存。</p><h2 id="tty结构体"><a href="#tty结构体" class="headerlink" title="tty结构体"></a><a id="chapter3.8">tty结构体</a></h2><p>第8题：tty结构体中大概包括哪些内容？ </p><p>（来自ORANGE’S的代码，解释也比较详尽了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_console</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TTY */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_tty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   u32    in_buf[TTY_IN_BYTES];  <span class="comment">/* TTY 输入缓冲区 */</span></span><br><span class="line">   u32*   p_inbuf_head;     <span class="comment">/* 指向缓冲区中下一个空闲位置 */</span></span><br><span class="line">   u32*   p_inbuf_tail;     <span class="comment">/* 指向键盘任务应处理的键值 */</span></span><br><span class="line">   <span class="type">int</span>    inbuf_count;      <span class="comment">/* 缓冲区中已经填充了多少 */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">s_console</span> * <span class="title">p_console</span>;</span></span><br><span class="line">&#125;TTY;</span><br></pre></td></tr></table></figure><h2 id="console结构体"><a href="#console结构体" class="headerlink" title="console结构体"></a><a id="chapter3.9">console结构体</a></h2><p>第9题：console结构体中大概包括哪些内容？</p><p>（来自ORANGE’S的代码）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CONSOLE */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_console</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   current_start_addr;    <span class="comment">/* 当前显示到了什么位置    */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   original_addr;    <span class="comment">/* 当前控制台对应显存位置 */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   v_mem_limit;      <span class="comment">/* 当前控制台占的显存大小 */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span>   cursor;          <span class="comment">/* 当前光标位置 */</span></span><br><span class="line">&#125;CONSOLE;</span><br></pre></td></tr></table></figure><p>这里xl还在console里面加了<strong>一个8位的无符号成员</strong>color（应该是用来完成Lab3的颜色需求的），答的时候可以加上。</p><h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a><a id="chapter3.10">时间片</a></h2><p>第10题：什么是时间片？ </p><p>答（<strong>《操作系统教程》第5版第105页</strong>）：调度程序把CPU分配给就绪队列首进程&#x2F;线程使用的<strong>规定的时间间隔</strong>。</p><p>来自<a href="https://github.com/EagleBear2002/OS-Lab4">xl的blog</a>：时间片是分时操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。</p><h2 id="内核函数与系统调用"><a href="#内核函数与系统调用" class="headerlink" title="内核函数与系统调用"></a><a id="chapter3.11">内核函数与系统调用</a></h2><p>第11题：结合实验代码解释什么是内核函数？什么是系统调⽤？</p><p>答：内核函数就是只能在内核态下调用的例程或子程序，比如kliba.asm中的disable_int，关中断显然不是用户进程能直接调用的（实际上这个文件里的所有函数都可以看作是内核函数）。</p><p>​而ORANGE’S中对于系统调用则有如下实现：</p><p>​先通过汇编代码（syscall.asm）完成<strong>参数的保存与发出中断</strong>，跳入内核态。内核态下调用<strong>中断处理例程</strong>（kernel.asm中）将控制权交给sys_call这一函数处理具体的系统调用型中断，该函数通过表驱动的方式再调用某一具体的系统调用函数（代码实现的位置因人而异）。</p><p><strong>To be continued…</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		如题，现在终于有时间来整理一下Lab4的内容了。不过Lab4的内容着实不多，而且相关的伪代码&amp;#x2F;代码要么ORANGE’S上面有，要么《操作系统教程》上面有(PV操作的伪代码)，要么助教补充的细节里面有，要么葛老师的PPT里有（读者优先），所以实现起来应该还好。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OSLab3随笔</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/19536.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/19536.html</id>
    <published>2023-05-07T07:43:33.000Z</published>
    <updated>2023-05-28T12:04:11.154Z</updated>
    
    <content type="html"><![CDATA[<p>​如题，这也是个非常普通的随笔。和以往不同的是，这次我暂且并不是写好了再写blog的，所以中间或许有翻车的可能性。（5.8更新：昨天下午开始做这个项目之后越写越嗨，不小心就写完了，结果这篇还是马后炮。这里顺便感谢助教wbgg，感谢他多次解答了我关于这个项目的疑惑，至于相应内容的公开，我还需要获得许可）(5.12更新：第六章中和进程有关的内容准备扔到Lab4的随笔去写了，对这次影响不大)</p><p>​这次的任务是和I&#x2F;O有关的，好消息是我们可以从ORANGE这本书上拿到很多有用的代码，其中的一部分甚至已经帮助我们完成了一部分的需求。坏消息是，书上走到这一步花了很大的篇幅去进行代码的书写，导致如果我们直接cv第七章最后的代码，容易感到无所适从，不知道从哪里开始动笔。大概我会花相当一部分的篇幅来做个书上内容的概括——这也权当是我自己的一点读书笔记，或者也可以起到一点导读的作用。之后对一些需要修改的<strong>无用的代码</strong>和我们<strong>可以利用的代码</strong>做一些简单的分析，最后进行一点点书写方面的<strong>简单描述</strong>。</p><p>​那么，继续吧。感谢诸位愿意继续看我胡言乱语。</p><p>​PS：如果想速通，跳到1.2和3.就行了。</p><p>​5.23 PS：关于问答，这里额外弄一个跳转链接：</p><p><a href="#chapter4.2.1">第1题：解释中断向量 </a></p><p><a href="#chapter4.1.1">第2题：解释中断类型码。</a></p><p><a href="#chapter4.2.1">第3题：解释中断向量表 </a></p><p><a href="#chapter4.2.2">第4题：实模式下中断程序地址如何得到？</a></p><p><a href="#chapter4.3.2">第5题：保护模式下中断程序地址如何得到?</a></p><p><a href="#chapter4.2.2">第6题：中断向量的地址如何得到? </a></p><p><a href="#chapter4.2.2">第7题：实模式下如何根据中断向量的地址得到中断程序地址? </a></p><p><a href="#chapter4.3.1">第8题：解释中断描述符。 </a></p><p><a href="#chapter4.3.2">第9题：保护模式下中断描述符表如何得到? </a></p><p><a href="#chapter4.3.2">第10题：保护模式下中断门如何得到?  </a></p><p><a href="#chapter4.3.2">第11题：保护模式下如何根据中断门得到中断处理程序地址?  </a></p><p><a href="#chapter4.1.2">第12题：中断的分类，并举例不同类型的中断。 </a></p><p><a href="#chapter4.1.4">第13题：中断与异常的区别?  </a></p><p><a href="#chapter4.4">第14题：实模式和保护模式下的中断处理差别 </a></p><p><a href="#chapter4.5.1">第15题：如何识别键盘组合键（如 Shift+a）是否还有其他解决方案? </a></p><p><a href="#chapter4.3.1">第16题：IDT 是什么，有什么作用? </a></p><p><a href="#chapter4.3.1">第17题：IDT 中有几种描述符? </a></p><p><a href="#chapter4.1.3">第18题：异常的分类?  </a></p><p><a href="#chapter4.5.2">第19题：用户态和内核态的特权级分别是多少?  </a></p><p><a href="#chapter4.2.1">第20题：中断向量表中，每个中断有几个字节?里面的结构是什么? </a></p><p><a href="#chapter4.1.4">第21题：中断异常共同点（至少两点），不同点（至少三点） </a></p><p><strong>实现过程中可能的问题</strong>，待补充：</p><p><a href="#chapter1.2">为什么用ORANGE的代码make image失败？</a></p><p><a href="#chapter1.1.4">为什么用ORANGE的代码跑起来后屏幕上有乱码？</a></p><p><a href="#chapter3.2.3">为什么明显不到20s就清屏了？</a></p><p><a id="list"><strong>目录</strong></a></p><p><a href="#chapter1">1. 工具箱，但是黑盒（在IO之前）</a></p><p><a href="#chapter1.1">1.1 逃离汇编</a></p><p><a href="#chapter1.1.1">1.1.1 加载内核文件</a></p><p><a href="#chapter1.1.2">1.1.2 进入保护模式</a></p><p><a href="#chapter1.1.3">1.1.3 内核提取与控制移交</a></p><p><a href="#chapter1.1.4">1.1.4 保护模式的延续</a></p><p><a href="#chapter1.2">1.2 自动化编译之路</a></p><p><a href="#chapter1.2.1">1.2.1 Makefile基础</a></p><p><a href="#chapter1.2.2">1.2.2 让我们的项目跑起来</a></p><p><a href="#chapter1.2.3">1.2.3 更加自动化</a></p><p><a href="#chapter1.3">1.3 IO的前奏</a></p><p><a href="#chapter1.3.1">1.3.1 特权级的限制与跨越</a></p><p><a href="#chapter1.3.1.1">1.3.1.1 CPL、DPL、RPL</a></p><p><a href="#chapter1.3.1.2">1.3.1.2 门</a></p><p><a href="#chapter1.3.1.3">1.3.1.3 被遗忘的堆栈</a></p><p><a href="#chapter1.3.1.4">1.3.1.4 call和ret；ret的独走</a></p><p><a href="#chapter1.3.2">1.3.2 中断机制的引入</a></p><p><a href="#chapter1.3.2.1">1.3.2.1 中断机制：理论</a></p><p><a href="#chapter1.3.2.2">1.3.2.2 中断机制：实现</a></p><p><a href="#chapter1.3.2.3">1.3.2.3 时钟中断和中断嵌套</a></p><p><a href="#chapter2">2. 工具箱，但是黑盒（IO）</a></p><p><a href="#chapter2.1">2.1 一次敲击的信息量</a></p><p><a href="#chapter2.1.1">2.1.1 建立连接</a></p><p><a href="#chapter2.1.2">2.1.2 Make Code和Break Code</a></p><p><a href="#chapter2.2">2.2 操纵显存</a></p><p><a href="#chapter2.2.1">2.2.1 显示内容和显示范围</a></p><p><a href="#chapter2.2.2">2.2.2 *多TTY的构建</a></p><p><a href="#chapter2.3">2.3 有用但残缺</a></p><p><a href="#chapter3">3. 正式修改</a></p><p><a href="#chapter3.1">3.1 我们有什么</a></p><p><a href="#chapter3.1.1">3.1.1 实现了什么</a></p><p><a href="#chapter3.1.2">3.1.2 手头的框架</a></p><p><a href="#chapter3.2">3.2 先从清屏开始</a></p><p><a href="#chapter3.2.1">3.2.1 *消灭用户进程和多TTY</a></p><p><a href="#chapter3.2.2">3.2.2 清屏</a></p><p><a href="#chapter3.2.3">3.2.3 时间的灾难</a></p><p><a href="#chapter3.3">3.3 一步一个脚印，但是速通</a></p><p><a href="#chapter3.3.1">3.3.1 基本功能速通</a></p><p><a href="#chapter3.3.2">3.3.2 查找功能速通</a></p><p><a href="#chapter3.3.3">3.3.3 撤回功能速通</a></p><p><a href="#chapter4">4. Lab3问答整理</a></p><p><a href="#chapter4.1">4.1 中断（通用）</a></p><p><a href="#chapter4.1.1">4.1.1 中断类型码</a></p><p><a href="#chapter4.1.2">4.1.2 中断的分类</a></p><p><a href="#chapter4.1.3">4.1.3 异常的分类</a></p><p><a href="#chapter4.1.4">4.1.4 中断与异常的异同</a></p><p><a href="#chapter4.2">4.2 实模式下的中断</a></p><p><a href="#chapter4.2.1">4.2.1 中断向量和中断向量表</a></p><p><a href="#chapter4.2.2">4.2.2 实模式下获取中断处理程序的入口</a></p><p><a href="#chapter4.3">4.3 保护模式下的中断</a></p><p><a href="#chapter4.3.1">4.3.1 中断描述符和IDT</a></p><p><a href="#chapter4.3.2">4.3.2 保护模式下获取中断处理程序的入口</a></p><p><a href="#chapter4.4">4.4 实模式和保护模式下中断处理的差别</a></p><p><a href="#chapter4.5">4.5 其他</a></p><p><a href="#chapter4.5.1">4.5.1 键盘组合键的识别</a></p><p><a href="#chapter4.5.2">4.5.2 用户态和内核态的特权级</a></p><h1 id="工具箱，但是黑盒（在IO之前）"><a href="#工具箱，但是黑盒（在IO之前）" class="headerlink" title="工具箱，但是黑盒（在IO之前）"></a><a id="chapter1">工具箱，但是黑盒（在IO之前）</a></h1><p>​这次实验反正明说了可以改随书光盘的代码，不过咱也不可能完全不看书直接cv代码就开始硬改，毕竟一百多页的和代码结合的内容，说实话真要吸收还挺麻烦的。所以，我们得先把ORANGE这几章讲了什么摸清楚（虽然要求说只要看三、四、五、七这四章，但第六章是进程相关的，不可能一点不去看），至少，先看看我们拿到的工具箱里有什么。</p><p>​</p><h2 id="逃离汇编"><a href="#逃离汇编" class="headerlink" title="逃离汇编"></a><a id="chapter1.1">逃离汇编</a></h2><p>​写汇编真的是很痛苦的一件事，可是就我们Lab1的进度来看，我们这个时候还得再苦一苦自己。我们Lab1的Loader并不是完整的，他只执行了一个打印的工作，别的啥都没干，这显然是不符合我们需要的。我们需要更多的地址空间、更加完备的设备管理、一些额外的访问控制，凡此种种，在现有的实模式下可能还是有些别扭了。此外，我们也想赶快开始进行c语言代码的编写。因此，进一步读取Kernel和<strong>开启保护模式</strong>势在必行，这就是第三、第四、第五章在做的事情。</p><h3 id="加载内核文件"><a href="#加载内核文件" class="headerlink" title="加载内核文件"></a><a id="chapter1.1.1">加载内核文件</a></h3><p>​光盘代码真正的工作推进是从5.4节开始的。首先是5.4.1节，这一节做了和我们lab1中boot.asm做的事情差不多的事——找到kernel.bin并加载之，再去放到合适的位置。成分的提取并没有马上就完成，因为涉及到一些其他函数的书写和调用，我们最好还是先把保护模式开起来再说。</p><h3 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a><a id="chapter1.1.2">进入保护模式</a></h3><p>​进入5.4.2节，我们需要跳入保护模式（相应的知识点在书<strong>第31至35页</strong>），在这里，我们需要准备好全局段描述符表（GDT），并且我们需要<strong>将基址和限长加载到GDTR</strong>中（lgdt指令）。之后因为一些历史遗留原因（第34页有讲述），我们需要<strong>打开A20地址线</strong>从而支持超过1M地址空间的寻址。接下来，将<strong>cr0寄存器的PE位置为1</strong>（若这一位为0，则为实模式），最后地址跳转，正式进入保护模式。</p><p>​进入保护模式后，我们初始化了寄存器——比如<strong>代码段寄存器</strong>等。同时为了虚拟存储的需求，我们<strong>开启了分页</strong>——在此之前，我们让内核打印了内存的相关信息。</p><h3 id="内核提取与控制移交"><a href="#内核提取与控制移交" class="headerlink" title="内核提取与控制移交"></a><a id="chapter1.1.3">内核提取与控制移交</a></h3><p>​然而，到这一步，loader的工作还没有完。我们读进来的elf文件里面的东西相当杂乱，我们还需要提取出其中的有效内容（<strong>elf文件的相关信息</strong>参见书上第5.3节）放到合适的地方去。这里我也给一张图辅助说明：</p><img src="/blogOfNoob.github.io/teawith/19536/structelf.jpg" class="" title="elf文件结构"><p>​首先<a id="fnobuiltin"></a>是ELF Header，这里面存储了一些信息，我们需要用到的有elf头的大小——这能帮我们定位<strong>program Header Table</strong>所在地，而这是我们真正需要的东西——这些程序头可以描述相关的段该被扔到内存中的什么位置，根据他们提供的信息，再配合第三章不知道什么时候写的memcpy函数（顺便一提，这个函数很明显和编译器的<strong>内建函数</strong>重名，所以我们编译时需要加上<strong>-fno-builtin</strong>编译选项，下文会进一步提到一些编译选项）完成对内核中真正有用的部分的迁移。在这里，上一次的Lab的提问中有提到linux开始编译的位置，由于我们是32位环境，所以编译器默认起始地址在0x08048000开始，这对于我们的实验并不一定合适，因此我们通过链接时额外指定起始地址来进行约束：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 -o kernel.o kernel.asm</span><br><span class="line">ld -s -Ttext 0x30400 -o kernel.bin kernel.o</span><br></pre></td></tr></table></figure><p>​至于为什么选择了<strong>0x30400</strong>这个值，书上第138到140页说的很清楚，我就不越俎代庖了。</p><p>​完成内核中的有效内容的提取后，我们只需要像在boot中做的那样，向内核移交控制权就好了。</p><p>​到这里为止，我们终于可以开始用c语言和汇编一同来书写我们的内核了——是的，从效用考虑，我们还不能完全放弃汇编，但麻烦的事情已经大大减少了。在汇编中使用<strong>extern关键字</strong>，我们可以调用相应的c函数以及访问相应的c代码中的全局变量，同时通过<strong>global关键字</strong>，也使我们能够完成对汇编的调用，相关内容参看书上第5.2节。</p><h3 id="保护模式的延续"><a href="#保护模式的延续" class="headerlink" title="保护模式的延续"></a><a id="chapter1.1.4">保护模式的延续</a></h3><p>​现在我们把控制权移交给了kernel，但是我们碰到了个问题，先不考虑一些深层次的问题，就说<strong>GDT里面的数据</strong>和堆栈吧，我们还放在loader里面呢。而且在c代码里面操作汇编里的某个数据结构……嘶。所以我们得在内核中整一个新的GDT出来。书上代码利用一个变量gdt_ptr进行操作，先将GDTR里面的内容存进去(sgdt指令)，在c代码中获得旧的GDT的地址与限长之后，取出其中的内容，放到新的GDT中，最后将新的GDT的基址和限长存到gdt_ptr中，到汇编代码中用lgdt将之加载到GDTR中。这是一个非常简单但是漂亮的<strong>汇编和c的协作</strong>的例子。</p><p>​接下来书上讲了一些宏定义和变量定义的内容，这些主要是为了编码方便——事实上实操的时候很容易也能看出来了。</p><p>​不过光盘里面的代码不一定完全适用于现在，至少接下来就有一个例子可以证明我们的观点，那就是kliba.asm（如果看第7章的光盘代码的话，这个汇编文件应该在lib文件夹下）下的<strong>disp_str函数</strong>（和他几乎类似的<strong>disp_color_str</strong>也有这个问题）。这里还看不出来有什么问题，不过后面cv代码跑起来之后就会看到，当这个函数在某次打印后打印出<strong>回车</strong>后，后续打印的内容对应的地址就飞到不知道哪里去了。原因是这个函数在<strong>检测回车的分支</strong>中，操作了<strong>基址寄存器ebx</strong>中的数据，却没有在操作前后<strong>进行被调用者保存与恢复</strong>。当然，这个其实不影响我们写这次lab，不过建议还是关注一下，修一下也很快，直接将觉得有风险的寄存器压栈（注意一下压栈的地方会不会影响到后续<strong>通过栈顶指针取参数</strong>，会的话改一下值就行了），后续再pop出来即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushebp</span><br><span class="line">pusheax;新加入</span><br><span class="line">pushebx;新加入</span><br><span class="line">movebp, esp</span><br><span class="line">movesi, [ebp + 16] ;修改数值</span><br><span class="line">  ... ...</span><br><span class="line">  pop ebx ;新加入</span><br><span class="line">  pop eax;新加入</span><br><span class="line">  pop ebp</span><br></pre></td></tr></table></figure><p>​到这里为止，书上整理了一下结构，所以后续的光盘代码结构就比较清晰了。而接下来，书上重点讲述了<strong>Makefile</strong>相关的内容。</p><h2 id="自动化编译之路"><a href="#自动化编译之路" class="headerlink" title="自动化编译之路"></a><a id="chapter1.2">自动化编译之路</a></h2><p>​每次都输一大堆命令着实很难绷，实际上在上一次的Lab中，我们就用到了Makefile。关于Makefile，书上写的比较明白了，不过考虑到我之前没仔细写过相关内容，这里还是写一下。</p><h3 id="Makefile基础"><a href="#Makefile基础" class="headerlink" title="Makefile基础"></a><a id="chapter1.2.1">Makefile基础</a></h3><p>​一个比较核心的语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">command</span><br></pre></td></tr></table></figure><p>​这个意思的含义是，要想得到target，需要执行command中的所有命令。target依赖于prerequisites，只有prerequisites中的文件至少有一个比target的新时，command才被执行。</p><p>​考虑到<strong>可修改性</strong>，我们可以将一些值用类似<strong>变量</strong>的方式存起来方便重用。为了方便，这里我直接以chapter 7中的某个Makefile作为例子（当然，这个makefile我修改过了）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASM= nasm</span><br><span class="line">ASMKFLAGS= -I <span class="keyword">include</span>/ -f elf32</span><br><span class="line">......</span><br><span class="line">kernel/kernel.o : kernel/kernel.asm <span class="keyword">include</span>/sconst.inc</span><br><span class="line"><span class="variable">$(ASM)</span> <span class="variable">$(ASMKFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>​比如这里，我们将编译汇编的工具nasm存到了ASM变量中，之后如果我们想要取出它的值该怎么办呢？我们可以用$取出其值，这样$(ASM)就得到了nasm这个字符串。类似地，ASMKFLAGS这个“变量”也是这样的作用。-o的作用我们已经很了解了——它指定了输出到什么文件。<strong>$@<strong>的意思是target，而</strong>$&lt;</strong>是prerequisites的<strong>第一个名字</strong>。</p><p>​之后，需要介绍一下<strong>.PHONY</strong>关键字：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : everything final image clean realclean disasm all buildimg</span><br></pre></td></tr></table></figure><p>​他的意思是，后面这些可以被理解为<strong>动作</strong>。当然，并不是只有被<strong>.PHONY</strong>修饰的内容才可以被make，这个的好处是，即使你的工作路径下有<strong>和动作同名的文件</strong>，依然可以正常make。</p><h3 id="让我们的项目跑起来"><a href="#让我们的项目跑起来" class="headerlink" title="让我们的项目跑起来"></a><a id="chapter1.2.2">让我们的项目跑起来</a></h3><p>​接下来我们要试着让我们自己的项目跑起来——他的Makefile不一定适用于我们的环境。</p><p>​我直接上我这里的<strong>关键设置</strong>，然后解释为什么：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ASMKFLAGS= -I <span class="keyword">include</span>/ -f elf32</span><br><span class="line">CFLAGS= -I <span class="keyword">include</span>/ -c -fno-builtin -m32 -fno-stack-protector</span><br><span class="line">LDFLAGS= -s -Ttext <span class="variable">$(ENTRYPOINT)</span> -m elf_i386</span><br></pre></td></tr></table></figure><p>​先从简单的开始说，CFLAGS中的<strong>-fno-builtin</strong>选项是原来自带的，原因<a href="#fnobuiltin">上面</a>也解释过了。</p><p>​-m32是编译32位代码，这也没什么好解释的。下面LDFLAGS中的<strong>-m elf_i386</strong>的意思是选择用elf_i386模拟器进行链接模拟32位环境。</p><p>​下面着重说一下<strong>-fno-stack-protector</strong>参数，他的作用是<strong>禁用堆栈保护</strong>。如果不禁用堆栈保护，编译器编译的时候会塞一个<strong>堆栈保护器</strong>——然而到了<strong>链接</strong>的时候，因为咱们没有引库函数，链接时直接原地爆炸，所以这里需要禁用堆栈保护。</p><p>​到这里为止，我们的项目应该可以一个make就编译好了，不过我们还得让他跑起来：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">run: image</span></span><br><span class="line">bochs</span><br></pre></td></tr></table></figure><p>​这样我们make run就可以启动虚拟机了。</p><h3 id="更加自动化"><a href="#更加自动化" class="headerlink" title="更加自动化"></a><a id="chapter1.2.3">更加自动化</a></h3><p>​不过其实，我们现在还有一些<strong>啸问题</strong>，比如我们必须假定我们有一个<strong>映像a.img</strong>，但如果没有，我们需要bximage。但bximage指令不可能不做其他操作吧？该怎么办呢？我在这部分就不禁感慨<strong>当年Linux没好好学</strong>。</p><p>​我们可以先用<strong>bximage --help</strong>命令看看有什么东西：</p><p>​<img src="/blogOfNoob.github.io/teawith/19536/bximagehelp.jpg" class="" title="bximagehelp"></p><p>​<strong>-q</strong>可以帮我们屏蔽用户的输入，同时-mode可以指定输入模式为create，-fd还能指定大小1.44M，最后我们再按照格式在最后加入a.img就行了。这很好，让我们试一试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bximage -mode=create -fd=1.44M -q a.img</span><br></pre></td></tr></table></figure><img src="/blogOfNoob.github.io/teawith/19536/bximagereplace.jpg" class="" title="bximagereplace"><p>​啊这，我们已经有了一个a.img了，现在提示我们要不要替换，这也是个额外操作，可是刚才看到的help也没说怎么处理这个啊。</p><p>​当然，我们可以判断下面有没有相应的文件，然后<strong>rm</strong>。但是我的室友教了我一个比较粗暴但是有用的办法——利用<strong>管道</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">yes</span> | bximage -mode=create -fd=1.44M -q a.img</span><br></pre></td></tr></table></figure><p>​Linux下面有一个<strong>可执行文件yes</strong>会不断打印y，这样的话就能帮我们自动确认了。</p><p>​另外一个问题是每次打开虚拟机的时候都会要<strong>输入一个c</strong>，这个我们也想自动化该怎么办？</p><p>​当然利用<strong>管道</strong>也不是不行，但这样会给调试带来一些麻烦，后续对虚拟机的调试输入必须通过管道而不是IO。</p><p>​事实上我们可以用<strong>bochs --help</strong>命令再看看有什么：</p><img src="/blogOfNoob.github.io/teawith/19536/bochshelp.jpg" class="" title="bochshelp"><p>​这里我们看到一个<strong>-rc选项</strong>，它可以批处理一个指定文件名中的debug命令，只要我们开一个文件，写上一个c，再指定其为<strong>-rc选项后面的文件名参数</strong>即可。</p><p>​到此为止，我们的自动化程度已经很高了。唯一可能需要手动的就是<strong>sudo</strong>时输入密码了——但是研究怎么密文存储还是有点麻烦的，应该这里不至于做到那么麻烦。</p><p>​<a href="#list">从这里返回目录</a></p><h2 id="IO的前奏"><a href="#IO的前奏" class="headerlink" title="IO的前奏"></a><a id="chapter1.3">IO的前奏</a></h2><p>​现在我们可能还能通过书写内核代码来实现我们的功能，但是作为一个操作系统，我们在假想中总是要把它移交给其他用户的。到那时，我们需要给他们提供一些调用内部代码的接口、提供独立的运行环境，并设计进程调度的内容，这些就是ORANGE<strong>第五章后半部分和第六章</strong>在做的事情。不过由于第六章中完全实现进程的部分对这次的影响不大，所以就放到下次随笔去写，我在后面会专门标出来需要<strong>处理</strong>哪些可能造成影响的第六章的内容。</p><h3 id="特权级的限制与跨越"><a href="#特权级的限制与跨越" class="headerlink" title="特权级的限制与跨越"></a><a id="chapter1.3.1">特权级的限制与跨越</a></h3><p>​这里我需要插入一段闲笔，来讲讲特权级的相关内容，接下来直到我们讲到中断机制为止的内容，将对应着ORANGE书上<strong>第48到62页</strong>讲述的内容。</p><p>​当我们需要引入用户程序时，我们不可避免地要面对一个问题：我们是不是允许用户程序直接使用代码，操纵所有的数据？答案恐怕是否定的，用户程序对一些内容——比如一些和段相关的寄存器的操纵显然不能被允许。于是我们需要一些接口来使用内部的资源和方法。因此，引入特权级是必然的事情。</p><h4 id="CPL、DPL、RPL"><a href="#CPL、DPL、RPL" class="headerlink" title="CPL、DPL、RPL"></a><a id="chapter1.3.1.1">CPL、DPL、RPL</a></h4><p>​比较容易想到的特权验证思路是针对被使用者和使用者设置相应的特权级，这就是<strong>DPL</strong>（Descriptor Privilege Level，这里的描述符Descriptor除了段描述符，还可能是<strong>门描述符</strong>，下面会说到）与<strong>CPL</strong>（Current Privilege Level）。这里需要额外解释所谓<strong>一致代码段</strong>与<strong>非一致代码段</strong>，所谓的<strong>一致</strong>，是指如果转移的目标是特权级更高的代码段，当前的特权级会<strong>延续下去</strong>。但是仅仅设置DPL和CPL是不够的，我们显然应该给一个低特权级的程序访问高特权级代码段的机会，但是如果这样，低特权级的程序是否有机会<strong>间接访问</strong>高特权级的数据呢？想想也令人发冷。因此我们要设置一个额外的<strong>RPL</strong>（Request Privilege Level），被调用者接收到一个选择子时，会将选择子里的特权级设置为<strong>调用者的特权级</strong>，在检查时则取CPL与RPL二者特权更强者。</p><p>​因此，我们再介绍一下DPL对应段的特权级要求，这一部分在书上第49页也有提到：</p><p>​对于数据段、<strong>调用门</strong>和<strong>TSS</strong>(Task State Stack，这是书上的说法，在<strong>第56页</strong>，我看网上对同一个东西还有Task State Segment的说法，它的作用是保有不同权限下的栈指针等)，DPL给出的是访问的<strong>最低特权级</strong>（即从该特权级向内核的特权级内的所有特权级的代码段可以访问）；对于非一致代码段，DPL给出的是访问的唯一特权级；对于一致代码段和通过调用门访问的非一致代码段，DPL给出的则是访问所需要的最高特权级。</p><p>​下一个问题是，如何实现<strong>不同特权级之间的转移</strong>？自然地，我们会想到<strong>jmp</strong>或者<strong>call</strong>这两个汇编指令。然而，如果我们只是在目标操作数中加上<strong>目标代码段的段选择子</strong>，由于上一自然段中讲述的特权级的限制，我们并不能实现较为全能的转移，对于非一致代码段，只能转向特权级相同的；若要跳转到一致代码段，也不能转向特权级更低的。</p><p>​现在我们面临两个问题：单纯的跳转无法实现自由的非一致代码段的转移。同时高特权级转向低特权级的代码段也不被允许。</p><h4 id="门"><a href="#门" class="headerlink" title="门"></a><a id="chapter1.3.1.2">门</a></h4><p>​在这里，我们可以引入一个所谓的<strong>“门”</strong>，实际上，它也是一种<strong>描述符</strong>：</p><img src="/blogOfNoob.github.io/teawith/19536/gateDescriptor.jpg" class="" title="gate"><p>​这里的选择子指的是对应代码段的选择子，偏移量自不必多说。第5个字节的属性中，DPL的含义上面已经提过，其他的属性在上一次Lab的回答中也基本描述过了。第四个字节（BYTE4）中的<strong>Param Count</strong>指的是参数的数量，其作用将在后面揭示。</p><p>​这样，通过门描述符选择子和偏移量，我们指定了将要跳转的地址，只不过和直接跳转不同的是，我们是利用了门在访问特权级上的的特殊性，而上面我们转述的DPL规则中有这么一条：</p><p>​<em>对于一致代码段和通过调用门访问的非一致代码段，DPL给出的则是访问所需要的最高特权级。</em></p><p>​这样对于一个低特权级的代码段，我们可以先跳到一个<strong>特权级一样或更弱的门</strong>处，通过调用门去访问<strong>特权级更强的代码段</strong>，这样我们就实现了低特权级到高特权级的跳转。不过在具体实现上，jmp和call又有所区别，请参见书上<strong>第54页给出的表格</strong>。</p><h4 id="被遗忘的堆栈"><a href="#被遗忘的堆栈" class="headerlink" title="被遗忘的堆栈"></a><a id="chapter1.3.1.3">被遗忘的堆栈</a></h4><p>​在上面热火朝天地讨论了半天各种各样的权限的时候，我们似乎忘记了什么，比如说，堆栈。</p><p>​作为一个非常方便的传递数据的结构，堆栈似乎也是不能在不同特权级的代码段之间随便就共享的。自然，在不同特权级之间切换时，我们也需要切换堆栈。但是问题来了，我们在call之前将调用者eip压栈，如果是长跳转，还会将cs寄存器的值压栈，这是期望在返回时，我们能够从堆栈中拿到这些值，可是我们已经切换了堆栈，这些值必须要以某种方式保存下来。此外，我们<strong>每个特权级如果都需要一个堆栈</strong>的话，在哪里存相应的值呢？</p><p>​这里我们不但没有解决剩下的从高特权级跳转低特权级的问题，还多了两个问题。不过，当我们解决这两个问题的时候，相应的跳转问题也将迎刃而解。</p><p>​首先是第一个问题，以Intel为例，它提供了某种机制，在堆栈之间复制内容（见书上第57页的图3.19）。</p><p>​对于第二个问题，我们引入了一种被称为<strong>TSS</strong>的数据结构：</p><img src="/blogOfNoob.github.io/teawith/19536/TSS.jpg" class="" title="TSS"><p>​最下面这些就是和堆栈相关的信息了，也正是我们需要的东西，当我们想要去寻找相关信息就可以从他们中去找。</p><h4 id="call和ret；ret的独走"><a href="#call和ret；ret的独走" class="headerlink" title="call和ret；ret的独走"></a><a id="chapter1.3.1.4">call和ret；ret的独走</a></h4><p>​于是对于长调用，我们有如下的步骤（在call之前<strong>参数即已压栈</strong>）：</p><p>​根据目标代码段的<strong>DPL</strong>，我们可以确定将要跳转到的特权级，进而去TTS中找寻对应的ss和esp并读取。既然是段的操作，如果发现ss、esp甚至是TSS的<strong>界限错误</strong>，将会导致<strong>无效TSS异常</strong>。接下来检验ss描述符，这中间也可能发生无效TSS异常。之后我们并不能直接切换或者将ss和esp压栈，因为我们要保证<strong>函数返回时</strong>，ss和esp必须<strong>在参数之后出栈</strong>，所以我们需要先暂存当前的ss和esp，然后将ss和esp切换为新的堆栈对应的值。到这里为止，我们切换到了新的特权级的堆栈，然后再将ss和esp压栈，这样他们就将在新堆栈中压在旧堆栈下面了。接下来我们将要回收一个伏笔：那就是调用门中的<strong>Param Count</strong>，根据这个值，我们可以将<strong>调用者堆栈</strong>中的相应数量的参数<strong>复制到被调用者堆栈中</strong>。最后，为了方便返回，我们将当前的cs和eip压栈，并加载新的cs和eip，开始被调用者过程。</p><p>​注意到Param Count只有5位，如果参数超过了31个（多少有点大可不必了），我们还可以让某个参数变为指向某个数据结构的指针，或者邪恶一点，用新堆栈中的ss和esp拿到旧堆栈的地址。</p><p>​返回（<strong>ret</strong>）时则几乎反过来。先检查保存的cs的<strong>RPL</strong>，从而确定返回时是否需要切换特权级。然后加载cs和eip，这其中的代码段描述符和选择子类型的<strong>特权级检查</strong>也少不了。之后，如果有参数，则跳过参数，接着加载ss和esp，回到<strong>被调用者堆栈</strong>，做相应的检验，丢弃被调用者的ss和esp。如果有参数，再<strong>在调用者堆栈中跳过参数</strong>。最后，如果不是一致代码段，还需要检查其他段寄存器的值，如果出现DPL小于CPL的情况，一个<strong>空的描述符</strong>会被加载到相应的段寄存器中去。</p><p>​但是，到这里，我们似乎还是没有解决从高特权级到低特权级的问题？</p><p>​对于ret指令，一般认为这是要和call成对出现的，但是从我们刚才的叙述中，其实不难发现，ret只不过是一系列操作的组合，或者也可以认为是封装。所以，我们当然可以<strong>单独出现ret</strong>——只要我们自己准备好了对应的要跳转到的代码段使用的堆栈相关的的ss、esp以及决定跳转地址的cs和eip，然后调用ret指令，就可以实现高特权级到低特权级的跳转——所谓的“地址跳转”，无非是<strong>修改cs和eip寄存器的值</strong>，只要实现了这组操作的指令，都可以认为是有跳转功能的。</p><h3 id="中断机制的引入"><a href="#中断机制的引入" class="headerlink" title="中断机制的引入"></a><a id="chapter1.3.2">中断机制的引入</a></h3><p>​实际上我们这一次需要完成的I&#x2F;O，从本质上来说并不属于系统内部，所以我们需要完成一套处理机制来打断当前的内核程序，从而使其处理来自系统内外的意外情况，也就是<strong>中断机制</strong>，这也正是书上接着在5.5.4节中进行的。</p><p>​不过在此之前，我们还是有必要<strong>从理论上</strong>了解一下中断机制。</p><h4 id="中断机制：理论"><a href="#中断机制：理论" class="headerlink" title="中断机制：理论"></a><a id="chapter1.3.2.1">中断机制：理论</a></h4><p>​中断的汇编指令相信诸位都不陌生了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 15h</span><br></pre></td></tr></table></figure><p>​对于中断，我们当然可以用表驱动的方式，维护一张中断向量表，将中断按照情况分为不同的类，并赋予中断向量号，然后根据中断时的中断向量号（中断向量号×4即为偏移量），获取相应的处理例程。</p><p>​但是现在我们到了<strong>保护模式</strong>下，事情开始发生了变化，我们的中断向量表变成了<strong>IDT</strong>（Interrupt Descriptor Table <strong>中断描述符表</strong>），其中的描述符有<strong>中断门描述符</strong>、<strong>陷阱门描述符</strong>和任务门描述符（Linux系统下不常用）。</p><p>​既然是门，它的结构就和调用门描述符的类似：</p><img src="/blogOfNoob.github.io/teawith/19536/intgate.jpg" class="" title="intGate"><p>​这里的段选择符（段选择子）将会指示中断处理例程所在的段，偏移量则指示例程始址在段内的偏移。其他的量作用也类似。</p><p>​从而我们可以给出保护模式下基于IDT的中断处理例程：</p><img src="/blogOfNoob.github.io/teawith/19536/intPro.jpg" class="" title="intPro"><p>​先通过<strong>IDTR</strong>拿到中断描述符表的基址和限长，然后通过中断向量号×<strong>8</strong> （中断门的大小，以字节为单位）拿到对应中断门的偏移量，这中间需要进行越界检查。通过取得的中断描述符中的选择子，根据其从0开始的第2位，选择GDT或LDT方式（见Lab2的问答部分）拿到对应的段描述符——这中间显然也有<strong>越界检查</strong>，这个段描述符的验权通过后，我们将会得到对应的中断服务子例程的起始地址，做相应处理后再转交控制权，就可以开始中断处理了。</p><p>​对于保护模式能处理的中断和异常有哪些，书上<strong>第89页</strong>的表格给的比较详细了。表格中“类型”这一列中，interrupt的的意思毋须多言，剩下三个概念，即<strong>fault、trap和abort</strong>，后面问答也会给出具（chao）体（shu）的定义。简单地说，这三个概念都是<strong>异常</strong>，区别在于，fault是可以被更正的异常，处理fault之前，将会将<strong>产生fault的指令</strong>之前的状态保存下来，处理之后，<strong>继续执行这一条指令</strong>。trap更像是<strong>请君入瓮</strong>，因此，不可能再跑一次诱发trap的指令，而是从它<strong>下一条指令</strong>继续执行。abort就比较糟糕了，他甚至<strong>不一定精确知道异常在哪里发生</strong>，程序和任务也没法继续跑下去了。</p><p>​接下来，书上还有一点关于中断的内容，事实上，中断也分为内外两种，内部中断就是直接由指令int n产生的中断，这类中断比较好处理，用上面的过程就行了；但对于外部中断就没那么乐观了，因为我们拿到的并非直接的中断向量号。下面是CPU处理外部中断的示意图：<img src="/blogOfNoob.github.io/teawith/19536/outInt.jpg" class="" title="outInt"></p><p>​对外部中断，又分两类：非屏蔽中断和可屏蔽中断，判断是否屏蔽可屏蔽中断是根据<strong>标志位寄存器的IF位</strong>（当<strong>为1</strong>时才发生可屏蔽中断），可以通过cli指令<strong>开屏蔽</strong>，sti指令<strong>关屏蔽</strong>。对于<strong>非屏蔽中断</strong>，通过<strong>NMI</strong>引脚线传入CPU，这类中断据<strong>第89页</strong>的表格，中断向量号为2。而<strong>可屏蔽中断</strong>又更复杂一些，它们产生的信号由<strong>两片级联的8259A</strong>（这是一种<strong>可编程中断控制器</strong>，其实就是一种芯片）通过<strong>INTR</strong>引脚线传入，共15种（其中IRQ15保留）。可屏蔽中断的发生与否除了受上文所述的IF位限制，还受到<strong>IRM</strong>（Interrupt Mask Register，中断屏蔽寄存器）、IRR（中断请求暂存寄存器）和ISR（中断服务寄存器）的影响。</p><p>​BIOS初始化8259A时，将IRQ0至IRQ7初始化为向量号08h至0Fh——这其实很坏，因为保护模式下它们已经被占用了。所幸8259A可以编程，我们可以再通过<strong>相应的端口</strong>，利用<strong>out</strong>指令，修改其<strong>IRQ</strong>与向量号的对应，具体的修改方法<strong>书上第91至92页</strong>写的比较清楚了，这里就不再引述了。需要提前搬运过来的是，对主8259A，20h端口是<strong>设置中断向量号</strong>，而21h端口是<strong>设置屏蔽或者将掩码写入IRM</strong>（当对应的位置为0时才发生），同理，对从8259A，A0h设置对应中断向量号，A1h端口设置屏蔽。</p><p>​8259A产生的可屏蔽中断处理完毕后，还需要再给20h或A0h端口发送<strong>EOI</strong>，将IRR和ISR等进行设置，保证可以继续处理接下来的中断。</p><p>​不过，上述内容仍然还没有完整地描述整个中断的过程，比如，从中断发生到转向初步的处理发生了什么？中断是怎么返回的？确切地说，我们要去关注其中<strong>堆栈的变化</strong>。</p><p>​其实中断之后转向处理例程<strong>无非也是一种跳转</strong>（<a href="#chapter1.3.1.4">上面</a>有讲到跳转），既然是跳转，<strong>cs和eip的压栈</strong>是少不了的。不过在此之前，以fault为例，因为我们要返回去<strong>在相同的状态之下</strong>执行对应的指令，所以也需要把<strong>eflags寄存器内的内容</strong>压入栈中。如果这其中涉及到了<strong>不同特权级的转移</strong>（一般来说，是从低到高），那么还需要堆栈切换、<strong>压入原来的ss和esp</strong>、压入eflags、cs、eip。在上述两种情况中，如果我们有错误码（这得根据<strong>第89页</strong>的表格，也就是<strong>表3.8</strong>），最后还应压入错误码。</p><p>​类似地，返回时我们也是用的ret，不过这里特殊一点，是<strong>iretd</strong>，它还会通过堆栈中保存的原来eflags寄存器的值来还原eflag寄存器的状态，不过还有一些限制，是和<strong>IO保护</strong>相关的，参见<strong>第99页</strong>。</p><p>​其实到这里为止，我们关于中断的理论部分就讲完了。将要进入到实践部分了，这将带我们回到书上<strong>第155页开始的内容</strong>。</p><h4 id="中断机制：实现"><a href="#中断机制：实现" class="headerlink" title="中断机制：实现"></a><a id="chapter1.3.2.2">中断机制：实现</a></h4><p>​其实完成一个漂亮的中断机制，从上面的讲述中可以看出，我们需要建立一套中断和异常的处理机制，同时对于外部中断，由于BIOS的设置问题，我们还需要一个例程重新<strong>初始化8259A</strong>，使其能够在保护模式下向CPU输出合适的中断向量号。书上先完成的是初始化8259A的工作。</p><p>​由于我们的编程必然要更多地在c语言下进行，于是书上封装了<strong>out_byte</strong>和<strong>in_byte</strong>这两个函数（在<strong>lib&#x2F;kliba.asm</strong>中），用以实现通过指定端口向特定外设读写的功能——这也是书上在第7章实现<strong>操纵外设</strong>的诀窍之一。这里书上又新建了一个头文件<strong>proto.h</strong>，用来存放函数声明。</p><p>​加这么多文件，条理性是强了，但是改Makefile添加依赖的时候就痛苦万分了。好在，gcc给我们提供了一条指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -M kernel/start.c -I include</span><br></pre></td></tr></table></figure><p>​其中-I这个选项的意思是<strong>指定头文件目录</strong>，在这里，我们的头文件都放在include目录下了，而<strong>-M</strong>会自动给我们生成所需要的依赖：<img src="/blogOfNoob.github.io/teawith/19536/dependency.jpg" class="" title="dependency"></p><p>​复制到Makefile就行了。</p><p>​完成初始化8259A后，我们需要搭起我们的中断和异常的处理机制，还是得先<strong>初始化IDT</strong>，这个利用初始化GDT的方式就行了。首先，我们要定义IDT的相关信息。类似地，我们也要<strong>定义门描述符的数据结构</strong>（在protect.h中）。接下来是将相应的内容<strong>加载到IDTR</strong>中，书上通过在汇编代码中<strong>extern idt_ptr</strong>（c代码中这个被宏定义的<strong>EXTERN</strong>实际上什么也没有），从而引入一个外部变量（在c代码里），先在c中预设相应的值，再直接在汇编中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lidt [idt_ptr]</span><br></pre></td></tr></table></figure><p>​从而将这个位置开始的6个字节加载入IDTR。</p><p>​初始化完成后，该处理中断或者异常了。从上面理论的部分中，我们知道了在中断发生时堆栈发生的变化，书上这里为了统一化处理，特地为没有错误码的异常push了中断码，然后调用c语言的函数<strong>exception_handler</strong>进行处理。</p><p>​然后这里书上把之前<a href="#chapter1.1.4"><strong>没有做被调用者保存</strong></a>的disp_str函数又复制了一遍写了个<strong>disp_color_str</strong>，我们自己再手动添加一遍被调用者保存吧（绷不住了，他怎么跑起来的）。</p><p>​不过我们到现在为止，似乎还没有<strong>添加IDT的表项</strong>，书上的处理方法是，用一个<strong>init_idt_desc</strong>函数处理，这里第三个参数填入的是<strong>对应处理例程的段内偏移量</strong>（通过在汇编中global标记对应的标签，这里实际指向的是汇编中的相应label），然后拆开来填到IDT的两段偏移处。</p><p>​到这里为止，书上第5章的使命已经基本结束。然而，这个中断并不完全完整——他连嵌套中断都没有实现。这些内容还得在<strong>第6章</strong>才做。同时，第6章还将实现一个获取当前ticks的系统调用（这很重要）。</p><p>​</p><h4 id="时钟中断和中断嵌套"><a href="#时钟中断和中断嵌套" class="headerlink" title="时钟中断和中断嵌套"></a><a id="chapter1.3.2.3">时钟中断和中断嵌套</a></h4><p>​这一部分是书上为了实现进程相关的功能（比如调度）而实现的，不过了解他，对于我们的实验也很重要（如果没有时间的概念，我们的20s清屏怎么做呢？）。</p><p>​书上将外设的初始化放在了<strong>kernel_main</strong>中。</p><p>​首先，时钟中断属于可屏蔽中断，我们需要打开它，这分两步走，首先是用<strong>sti指令</strong>设置标志寄存器的<strong>IF位</strong>为1从而<strong>打开对可屏蔽中断的接收</strong>，接下来我们还要特定地打开对时钟中断的接收，时钟中断在<strong>主8259A</strong>上处理，所以我们给<strong>21h端口</strong>发送0xFE，将时钟中断在IMR（中断屏蔽寄存器）中的对应位<strong>设置为0</strong>，至此，打开了时钟中断。</p><p>​亦如上文所述，我们需要在处理完可屏蔽中断后给8259A的20h端口<strong>发送EOI</strong>，不然，将无法处理后续发生的中断。</p><p>​这里书上还在<strong>iretd之前</strong>设置了TSS的esp0（也就是特权级0下的栈指针寄存器）。因为设置的内容和进程相关的知识有关，所以这里我们只需要解释<strong>为什么要在这里设置</strong>。iretd将会从内核态返回，而下一次从用户态进入内核态时，将会借助于TSS的esp0，所以在iretd之前，必须将TSS的esp0设置为正确的值。</p><p>​注意，为了不扰乱进程表，时钟中断要<strong>使用内核栈</strong>。</p><p>​接下来书上还做了<strong>中断嵌套</strong>的处理（利用全局变量）。</p><p>​这之后，到203页开始，书上又添加了对时钟中断的进一步处理，加入了<strong>进程调度</strong>的内容。紧接着，根据Minix的中断处理机制，整理了相关的中断处理代码。并且引入了<strong>enable_irq和disable_irq</strong>这两个函数（在lib&#x2F;kliba.asm中，虽然这两个函数中只有cli指令，但是通过标志位寄存器的pushf和popf，可以实现状态的调整）用于开关8259A对中断的接收情况。另外，现在添加c的中断处理程序可以直接使用<strong>put_irq_handler</strong>这个函数将<strong>irq_table</strong>对应的位置置为指定的处理例程，而不是去改汇编（因为汇编中已经写了相应的代码，会直接跳到这个数组的对应位）。</p><p>​本来，应该继续下去去把<strong>系统调用</strong>这一块讲完的，但是这次实验并不需要了解到底发生了什么，而且相关的实现在Lab4更为重要，我会把需要的函数在后面列出来。此外，再不进入IO的部分，别说大伙了，我都嫌烦了。</p><h1 id="工具箱，但是黑盒（IO）"><a href="#工具箱，但是黑盒（IO）" class="headerlink" title="工具箱，但是黑盒（IO）"></a><a id="chapter2">工具箱，但是黑盒（IO）</a></h1><p>​终于！我们摸到了这次实验的门槛，要正式开始接触IO相关的实现了。更重要的是，接下去我会讲述的内容，基本和实验非常相关了——这将提示我们在哪里去修改我们的代码。</p><h2 id="一次敲击的信息量"><a href="#一次敲击的信息量" class="headerlink" title="一次敲击的信息量"></a><a id="chapter2.1">一次敲击的信息量</a></h2><p>​我们这次的实验和两个外设有关——键盘和显示器。</p><p>​不妨按着书上的顺序，来看看一次键盘“敲击”都传达了什么信息吧。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a><a id="chapter2.1.1">建立连接</a></h3><p>​作为一种IO外设，键盘向CPU传递信息也是通过中断。所以，我们得先<strong>打开键盘中断</strong>。处理的方法和上面打开时钟中断类似，不过这次我们有了封装好的函数——<strong>enable_irq</strong>，这里传入的参数是<strong>需要屏蔽的IRQ号</strong>。书上用一个<strong>init_keyboard</strong>（在keyboard.c中）函数封装了键盘外设的初始化并放在了<strong>kernel_main</strong>(在main.c中)。</p><p>​同时，光有中断是不够的，我们还要建立一个键盘中断处理例程<strong>keyboard_handler</strong>，这个函数在keyboard.c中。这里书上让他先只打印一个*号，结果一次按键打印*号后，不管再敲击几次，都不再打印，这就引出了书上关于键盘物理实现的讨论。</p><p>​直接处理键盘<strong>事件</strong>的是8048芯片和相关的兼容芯片，统称为<strong>键盘编码器</strong>，他们会把一次事件的<strong>信息</strong>——这里我用了两个模糊的描述，是因为之前的“敲击”并不一定等于会引起响应的一次事件，所谓的信息到底是什么则会在下文阐释——发送给与其相连的<strong>键盘控制器</strong>（由8042及与其兼容的芯片组成），后者维护了一个<strong>缓冲区</strong>，将接收到的信息放入这个缓冲区中，只有当缓冲区清空，才继续接收信息。这也就是上面只响应了一次键盘事件的原因。</p><p>​那么，怎么读取缓冲区中的信息并清空之呢？</p><p>​上面我们提到过，CPU与这些IO外部设备的通信是通过“端口”的。书上<strong>第245页</strong>的表<strong>7.1</strong>给出了8042与CPU通信的端口，以及行为设置带来的影响，要想清空缓冲区，我们只要用汇编的<strong>in指令</strong>来从<strong>0x60</strong>端口读入信息，而到这里，光盘代码已经封装了一个in_byte函数，我们在参数中传入端口号就能拿到返回的字节了。因此，我们只需要在<strong>keyboard_handler</strong>中调用一个in_byte函数从0x60h端口读入一个字节即可。加入之后，再跑一次，我们将会发现按下再松手后，屏幕上出现了两个*，这说明处理了<strong>两个事件</strong>。</p><h3 id="Make-Code与Break-Code"><a href="#Make-Code与Break-Code" class="headerlink" title="Make Code与Break Code"></a><a id="chapter2.1.2">Make Code与Break Code</a></h3><p>​考虑一种情况，就是我们平时进行大写使用的一种方法：shift+字母，我们必须同时按下两者才会有大写。因此，除了<strong>按下</strong>，<strong>释放</strong>也应该是一个事件，于是在这其中产生了两次事件，每次事件传送了一次信息，这中间被传送的信息称为<strong>扫描码</strong>。对于除了Pause键以外的其他按键，按下时，发送<strong>Make Code</strong>，松开时，发送<strong>Break Code</strong>。相应的扫描码表参见<strong>书上第247至248页的表7.2</strong>。可以注意到的是，对于<strong>不是E0或E1开头</strong>的按键，他们的Make Code和Break Code大致满足以下条件：</p><p>​<strong>Break Code &#x3D; Make Code | 0x80</strong>;</p><p>​这就给我们的实现带来了一些启示：进行特判排除不一般的扫描码后，我们可以用得到的扫描码<strong>与</strong>上0x80来判断它是Make Code还是Break Code，事实上，书上也是这么做的。</p><p>​当然了，谁都不想一个一个扫描码去硬判断，好在这些扫描码是连续的，我们可以用<strong>数组</strong>来存放<strong>每个Make Code对应的按键</strong>，相应的定义在<strong>keymap.h</strong>里。另外，<strong>keyboard.h</strong>中也用宏定义了一些非常方便的量，比如上述的0x80。</p><p>​从上面的描述中，我们已经可以实现单一按键的处理，但是对于组合键，比如shift和其他按键同时按着的配合，又该怎么办呢？</p><p>​书上（现实中大概也是如此）采取了一个缓冲区的方法，就是CPU读入0x2A（左shift对应的Make Code）这类扫描码时，先<strong>存到缓冲区</strong>里，根据进一步的处理来判断。</p><p>​所以，我们实现处理的时候，也没必要每次只处理一个字符，而是封装一个函数，用以从设定的缓冲区中读取字节——这样我们可以在一次处理过程中处理多个扫描码。不过，由于按下不同的键仍然分属不同的事件，所以我们仍然不大可能一次就处理组合键的问题。</p><p>​还有另一个问题，那就是像F1这种<strong>非打印字符</strong>怎么办。书上采用了一种很巧妙的做法。扫描码实际上只占8位，但我们不一定要局促地按照8位来写我们每个Make Code对应的按键。书上通过一种类似于<strong>掩码</strong>的形式，将所有非打印字符都加上一个FLAG_EXT（其数值为0x0100）（参见keymap.h和keyboard.h），到字符处理时，通过扫描码<strong>按位与</strong>0x0100，如果不为0，则为非打印字符，从而能做进一步地处理。<strong>位运算</strong>的思路其实很有用。</p><p>​至此，书上先通过keyboard.c中的<strong>keyboard_read</strong>函数，对扫描码进行了一些简单的处理和输出，但是我们现在没必要去细究它，可以只是稍微看一下这个函数现在做了什么，因为这远非最终的代码结构。</p><p>​</p><h2 id="操纵显存"><a href="#操纵显存" class="headerlink" title="操纵显存"></a><a id="chapter2.2">操纵显存</a></h2><p>​按照书上的顺序，书上是讲了TTY和console，不过这部分理解起来，概念真的非常含混不清——而且事实上我们后续的实现中，完全可以不用考虑多终端的事情。只要知道在ORANGE的代码体系里面，console起了<strong>主要的操纵显存的作用</strong>就行了。</p><h3 id="显示内容与显示范围"><a href="#显示内容与显示范围" class="headerlink" title="显示内容与显示范围"></a><a id="chapter2.2.1">显示内容与显示范围</a></h3><p>​显存并不完全是简单的字符记录——我们之前的实验中实现过不同的字色——甚至包括<strong>前景色和背景色</strong>。因此，以我们实验环境下的显存为例，低8位是字符本身，高4位是背景色，中间4位是前景色。对于前景色和背景色的4位而言，从低到高分别是B、G、R和高亮设置。比较舒服的是，后面的成品代码已经给出了显存的相关数据，以及操作显存的相关方法，编程时直接调用即可。</p><p>​然而，以实验环境下的显存为例，其大小足足有0x8000，可是我们的屏幕就这么大，该怎么去决定显示哪块区域呢？这是由对应外设上的寄存器决定的。要操纵这些寄存器的值，还得通过相对应的端口，相关的端口信息在<strong>第266页上的表7.3</strong>有给出。不过我们编程的时候也不需要去考虑这些——ORANGE帮我们封装好了我们这次需要用到的内容，我们只需要修改c代码中某些变量的值即可。</p><p>​值得注意的是，这张表中的CRT Controller寄存器中的数据寄存器中，恰好有<strong>与游标（cursor）和显示始址相关的内容</strong>，当然，这就是我上一段说的封装好的端口操作——通过<strong>flush函数</strong>和其调用的<strong>set_cursor与set_video_start_address</strong>函数完成游标位置和显示始址的设置。</p><p>​据此，书上完成了调整游标和手动滚屏的代码实现——不过我们只需要前者。</p><h3 id="多TTY的构建"><a href="#多TTY的构建" class="headerlink" title="*多TTY的构建"></a><a id="chapter2.2.2">*多TTY的构建</a></h3><p>​接下来这部分，对我们的实验还是有一定影响的，但我后面第三部分中还会梳理一下函数的关系，所以也可以不怎么看</p><p>​这里实现了一个<strong>TTY任务</strong>——按照这本书的语境，<strong>目前</strong>就是一个进程。这个任务所做的工作在<strong>tty.c的task_tty函数</strong>中有所体现。简单来说，在tty任务中先初始化各个tty——各个tty再初始化自己负责的IO外设（当然，共用的外设在<strong>kernel_main</strong>中就初始化完成了），这里就只有显示屏一个，具体来说，初始化显示屏时设置了控制台的一些信息。然后就进入轮询。由于进程调度的存在，因此不用担心死循环。tty<strong>任务</strong>在自己分得的时间内会不断去轮询各个TTY，如果当前TTY和当前console一致，那就从<strong>内存中的</strong>键盘缓冲区读取数据（调用<strong>keyboard_read函数</strong>，再将信息交给<strong>in_process函数</strong>），再看是否进行输出。</p><p>​之所以我还要把这部分挑出来讲，一个是到此为止我们的键盘事件处理并没有完成，后续要想修改还得了解这个框架。另外一方面是，这边开始实现了一些职责的分离，keyboard_read<strong>将扫描码转化为后续处理所需要的key</strong>，在后续的<strong>in_process函数</strong>中进行分析，如果有需要，再放入内存中的键盘缓冲区，写的时候调用<strong>out_char</strong>函数进行打印。</p><p>​然后就是一个需要我们修改的部分，这里他实现了多console，不过对于我们来说，没啥必要。这里还实现了Alt + Fx切换控制台的功能。以及到这里他还添加了<strong>自动屏幕滚动</strong>的功能（比较坑人的是只实现了一半，也就是输入字符超出屏幕显示范围会向下滚屏，但是没实现删除的时候屏幕自动向上滚动）。</p><p>​</p><h2 id="有用但残缺"><a href="#有用但残缺" class="headerlink" title="有用但残缺"></a><a id="chapter2.3">有用但残缺</a></h2><p>​书上接下来做的是键盘处理的进一步完善，这部分的代码很有用——但不一定完全符合我们的需求。</p><p>​一个处理是<strong>回车和退格</strong>，这部分是先用<strong>in_process</strong>函数进行处理——这俩都是<strong>非打印字符</strong>，然后转化为一个字符放进缓冲区中等待输出。在<strong>out_char函数</strong>中完成输出。不过这个退格没完全做好，当换行再退格，甚至不能退到上一格的最后（这也等着我们去实现）。</p><p>​另外一个是<strong>Caps Lock</strong>大写锁定以及Num Lock、Scroll Lock的实现——实际上我们只需要第一个就行了。他们之所以被放到这里，是因为书上的实现还涉及小灯——不过这和我们的实验没有关系。事实上，我们还可以惊喜地发现，书上的代码还帮我们完全实现了第2点：当我们<strong>大写锁定和shift组合使用时</strong>，会打印出小写字符。这一部分甚至实现了虚空的小键盘。</p><p>​接下来是<strong>区分用户进程和任务</strong>，这一部分倒是方便我们修改了——比如把自带的用户进程踢出调度队列。</p><p>​最后是实现printf系统调用，这一部分也没啥用。</p><h1 id="正式修改"><a href="#正式修改" class="headerlink" title="正式修改"></a><a id="chapter3">正式修改</a></h1><p>​首先我们得找到光盘里一份能输出的代码，我用了chapter 7的o。</p><h2 id="我们有什么"><a href="#我们有什么" class="headerlink" title="我们有什么"></a><a id="chapter3.1">我们有什么</a></h2><p>​接下来我们得明确两件事：我们实现了什么，当前的逻辑是怎么样的（或者说必要的框架代码是什么）。</p><h3 id="实现了什么"><a href="#实现了什么" class="headerlink" title="实现了什么"></a><a id="chapter3.1.1">实现了什么</a></h3><p>​不妨先按照<a href="#chapter1.2">1.2节的内容</a>修改一下Makefile然后跑起来，看看我们<strong>已经实现了什么</strong>。</p><p>​经过测试（很显然<strong>查找模式和撤回这两大功能光盘的代码都没实现</strong>），基本模式下的功能实现情况如下：</p><p>​1、从屏幕左上角开始，以白色显示键盘输入的字符。可以输入并显示 a-z,A-Z 和 0-9 字符。 ——<strong>完全实现</strong></p><p>​2、大小写切换包括 Shift 组合键以及大写锁定两种方式。大写锁定后再用 Shift 组合键将会输入小写字母——<strong>完全实现</strong> </p><p>​3、 支持回车键换行。——<strong>完全实现</strong></p><p>​4、支持用退格键删除输入内容。 ——<strong>实现了一部分</strong>，但是回车再退格会回到上一行<strong>物理上的最右边</strong>。</p><p>​5、支持空格键和 Tab 键（4 个空格，可以被统一的删除） ——<strong>实现了空格没实现TAB</strong>。</p><p>​6、每隔 20 秒左右, 清空屏幕。输入的字符重新从屏幕左上角开始显示。——<strong>完全没实现</strong>。</p><p>​7、要求有光标显示, 闪烁与否均可, 但⼀定要跟随输入字符的位置变化。 ——<strong>完全实现</strong>。</p><p>​8、不要求支持屏幕滚动翻页，但输入字符数不应有上限。 ——支持了屏幕滚动翻页。</p><p>​9、不要求支持方向键移动光标。——没实现也不用实现。</p><p>​看起来，似乎还挺乐观？</p><h3 id="手头的框架"><a href="#手头的框架" class="headerlink" title="手头的框架"></a><a id="chapter3.1.2">手头的框架</a></h3><p>​下一步是看看我们手头有什么。打开这么大的一个代码文件，很多人，包括我，可能都是很迷茫的，不知道从哪里入手，所以我这里再用一张图归纳一下可能会较大影响到我们修改的书上代码（红笔写的是我们需要实现的内容的一部分）实现：</p><img src="/blogOfNoob.github.io/teawith/19536/structure.jpg" class="" title="结构"><p>​当我们触发键盘事件后，相应的<strong>扫描码</strong>被8048发给8042，<strong>存储到8042的缓冲区中</strong>，8042向CPU发出中断，进入中断处理例程，中断处理例程<strong>调用keyboard_handler函数从8042的缓冲区中读取扫描码到CPU的缓冲区中</strong>，完成键盘中断处理。</p><p>​而在自己被分配的时间中，<strong>task_tty先是进行初始化</strong>——这只进行一次。然后<strong>进入轮询</strong>，<strong>对每个TTY</strong>，先调用<strong>tty_do_read</strong>，进入后先<strong>验证当前TTY和console是否对应</strong>，如果否，返回。如果是，调用keyboard_read函数，检测<strong>内存缓冲区</strong>，从中取出扫描码，分析后<strong>转化为一个32位的key</strong>传给in_process函数做进一步的处理，这个函数中，如果遇到可打印字符就直接送入缓冲区，如果是非打印字符，就进一步分析，之后碰到退格和回车就转化为对应的字符，然后放入缓冲区。再返回。在task_tty中<strong>调用tty_write函数</strong>，如果缓冲区内有需要处理的key，就从缓冲区中取出key，<strong>转化为char</strong>，<strong>交给out_char函数进行处理</strong>。</p><h2 id="先从清屏开始"><a href="#先从清屏开始" class="headerlink" title="先从清屏开始"></a><a id="chapter3.2">先从清屏开始</a></h2><p>​如果看官是直接跳到这查看的，那么在上一步——查看已有实现中，您很可能会看到乱码，这是由于disp_str的错误引起的（实际上disp_color_str也有这个问题，但没调用过）（参见<a href="#chapter1.1.4">这里</a>）。虽然可能对后续实验没影响，但是这毕竟操作了ebx基址寄存器，说不定会影响寻址？建议还是改过来。</p><p>​然而，屏幕上这个时候已经有了许多输出，所以我们不妨先实现清屏。</p><p>​当然，也可以不从清屏开始——从清屏开始的话，后续要不断调整这个清屏函数，这只是我自己的一个实现顺序，具体怎么样还得看自己的思路。</p><h3 id="消灭用户进程和多TTY"><a href="#消灭用户进程和多TTY" class="headerlink" title="*消灭用户进程和多TTY"></a><a id="chapter3.2.1">*消灭用户进程和多TTY</a></h3><p>​如果搬运的是o的代码，那么我们可以看到屏幕上持续不断地进行输出，这很不好。</p><p>​我们可以在main.c里面找到<strong>TestA、TestB、TestC这三个函数</strong>，他们是造成持续输出的罪魁祸首。</p><p>​当然，我们可以只是注释掉他们的打印函数，但是仅此而已的话，他们仍然会和我们的TTY任务争抢时间片。我们这里更可以考虑将他们“消灭”。</p><p>​这里o的代码的可贵之处就体现出来了，因为<strong>区分了任务和用户进程</strong>，所以我们可以低成本地去进行修改。</p><p>​改两个地方，一个是<strong>include文件夹下的proc.h</strong>，找到<strong>NR_PROCS</strong>，将其值改为0，表示没有用户进程。</p><p>​另一个地方是<strong>kernel文件夹下的global.c</strong>，找到这样一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC  TASK    user_proc_table[NR_PROCS] =&#123;</span><br><span class="line">    ......<span class="comment">//这里省略一些内容，这些内容可以都注释掉</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​注释相应的内容，再检查一下kernel_main这个函数中的初始化进程表的部分，看看有无越界，这样就算清理完毕了。</p><p>​所有TTY任务的初始化都在task_tty里被调用，是一个循环，我们可以Ctrl点击<strong>TTY_END</strong>这个宏，找到其定义，是TTY _START加上一个数<strong>NR_CONSOLES</strong>，我们将之改为1即可。</p><p>​当然，还有一些其他的工作要做，比如修改init_screen函数中的逻辑。</p><p>​不过其实不消灭多TTY也不是不行，这样只是为了使用一个显存的大小（实际上肯定用不到这么大）。</p><h3 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a><a id="chapter3.2.2">清屏</a></h3><p>​到这里，基本上该完成的调整都做完了（实际上存疑）。我们可以去实现一个清屏了。注意，显存的单位实际上应该被看做是16位的，我们清屏的时候只应该修改低8位——那是和ascii码有关的数值，至于该改成啥，就不说了。</p><p>​此外，我们还应该重置游标和显示始址，这两个数值的参数，CONSOLE这个结构体里都有，修改对应参数后，调用封装好的<strong>flush函数</strong>调整游标和始址即可。</p><h3 id="时间的灾难"><a href="#时间的灾难" class="headerlink" title="时间的灾难"></a><a id="chapter3.2.3">时间的灾难</a></h3><p>​现在既然我们已经有了一定的输入能力，何不验证一下20s清屏能否实现？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lastTick = get_ticks(); <span class="comment">//不严谨的话sys_get_ticks()也可以，而且更直接</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">/*这是之前的框架*/</span></span><br><span class="line">    <span class="keyword">if</span> ((get_ticks() - lastTick) * HZ &gt; <span class="number">20000</span>)&#123; <span class="comment">/*HZ这个宏的意思是CPU频率,1tick = 1/HZ*/</span></span><br><span class="line">      clean_screen(...);<span class="comment">//参数略去</span></span><br><span class="line">        lastTick = get_ticks();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...... <span class="comment">//一些其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​看上去逻辑没啥问题，不是吗？</p><p>​实际跑起来，可能发现清屏的时间有些不大对劲？不是20s左右？（如果是的话可以跳过这一部分到下个标题）</p><p>​时间都去哪了？</p><p>​实际上，这可能和bochs有关，它模拟了一台电脑，但是bochs的时间是正确的时间吗？ORANGE的一个”tick”，<strong>在计算上</strong>等同于10ms，可是物理上似乎并不等于10ms？</p><p>​是的，这和bochs中的某个设置有关，我们应当检查<strong>bochsrc</strong>中有无下面这一行，原因稍后解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clock: sync=realtime</span><br><span class="line"># 备注：上面这个写both应该也可以</span><br></pre></td></tr></table></figure><p>​如果我们并不设置，那么bochs的这个机子，它的时钟就受到我们电脑的IPS（每秒执行指令数）影响，这其中的问题不言自明：我们的计算机越快，bochs的时钟就越快，相关选项的解释我复制如下：</p><p><em><strong>sync</strong>: This defines the method how to synchronize the Bochs internal time with realtime. With the value ‘none’ the Bochs time relies on the IPS value and no host time synchronization is used. The ‘slowdown’ method sacrifices performance to preserve reproducibility while allowing host time correlation. The ‘realtime’ method sacrifices reproducibility to preserve performance and host-time correlation. It is possible to enable both synchronization methods.</em></p><p>​因此，我们可以将同步设置为<strong>realtime或者both</strong>来使bochs的时钟和实际的保持一致，但是对他们的影响，我没有具体研究过，就不发表评论了。</p><h2 id="一步一个脚印，但是速通"><a href="#一步一个脚印，但是速通" class="headerlink" title="一步一个脚印，但是速通"></a><a id="chapter3.3">一步一个脚印，但是速通</a></h2><p>​接下来，我会把速度提上来——因为接下来涉及具体实现细节的比较多，并不方便显式给出，只能写一下自己的思路。</p><h3 id="基本功能速通"><a href="#基本功能速通" class="headerlink" title="基本功能速通"></a><a id="chapter3.3.1">基本功能速通</a></h3><p>​我们可以先实现TAB的<strong>\t</strong>，因为如果先完善退格的话，实现TAB的时候还是得去改退格。</p><p>​因此，我们可能需要一个区域来<strong>记录和文本相关的信息</strong>——不管他是什么，不然怎么区分TAB和SPACE的空格呢？当然，加入这个区域的话，我们<strong>清屏的时候</strong>也得维护一下相应的内容。</p><p>​然后是退格，这也不难，因为我们已经有了一个区域，每次退格时<strong>取出最新的ascii并做相应的处理即可</strong>。</p><p>​结束了，基本功能完成了。</p><h3 id="查找功能速通"><a href="#查找功能速通" class="headerlink" title="查找功能速通"></a><a id="chapter3.3.2">查找功能速通</a></h3><p>​由要求不难得知，我们有三种模式，分别是<strong>插入模式、查找-插入模式、查找-显示模式</strong>，因此，我们需要一个量来标记。</p><p>​查找模式的文本可以和插入的存在一个地方，也可以不存在一个地方，前者需要额外维护一些标记量。</p><p>​找到in_process中<strong>对ESC处理</strong>的部分（如果没有就自己加一个），加上一些操作，包括模式的转化和<strong>退出查找模式时的处理</strong>。</p><p>​ENTER在查找-插入模式下应该有新的功能。</p><p>​注意，查找-显示模式下应当<strong>屏蔽除了ESC以外的所有键盘IO</strong>。</p><p>​一些实现细节就不列出来了，于是查找功能也完成了。</p><h3 id="撤回功能速通"><a href="#撤回功能速通" class="headerlink" title="撤回功能速通"></a><a id="chapter3.3.3">撤回功能速通</a></h3><p>​首先我们需要捕捉CTRL + Z，不妨先看看这种按键情况下<strong>会不会有输出</strong>，从而确定这个key到底在in_process的哪里被处理。</p><p>​然后看一看keyboard_read有没有一些针对CTRL的特殊处理和衍生处理，比如位运算，从而<strong>确定判断CTRL +  Z</strong>的策略，我们可以通过检测到后就直接返回，运行时看有没有输出，来检查我们做的对不对。注意CTRL有左右之分。</p><p>​撤回本质是逆操作，于是我们显然可能也要维护一个区域<strong>记录和操作相关的信息</strong>。既然如此，清屏时也要做相应的处理。另外，<strong>\b并不是一个有用的操作信息</strong>。</p><p>​好了，撤回功能也完成了。</p><h1 id="lab3问答整理"><a href="#lab3问答整理" class="headerlink" title="lab3问答整理"></a><a id="chapter4">lab3问答整理</a></h1><p>​这次看了一下，一些问题的情境是连续的，所以整理时不一定按照问题的顺序去整理，而是取出其中类似问题域的问题做一个整合。</p><p>​</p><h2 id="中断（通用）"><a href="#中断（通用）" class="headerlink" title="中断（通用）"></a><a id="chapter4.1">中断（通用）</a></h2><p>​<strong>相关问题：</strong></p><p>​第2题：解释中断类型码。</p><p>​第12题：中断的分类，并举例不同类型的中断。</p><p>​第13题：中断与异常的区别? </p><p>​第18题：异常的分类? </p><p>​第21题：中断异常共同点（至少两点），不同点（至少三点）</p><h3 id="中断类型码"><a href="#中断类型码" class="headerlink" title="中断类型码"></a><a id="chapter4.1.1">中断类型码</a></h3><p>​<strong>相关问题：</strong></p><p>​第2题：解释中断类型码。</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n</span><br></pre></td></tr></table></figure><p>中断类型码是上面这个指令中的n，就是中断号，表示中断的类型。比如int 10h中的10h就是一个中断类型码，表示BIOS中断。</p><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a><a id="chapter4.1.2">中断的分类</a></h3><p>​<strong>相关问题：</strong></p><p>​第12题：中断的分类，并举例不同类型的中断。</p><p>答：按照中断源来分，可以分为三类，一类是由计算机硬件异常或故障引起的中断，也称为<strong>内部异常中断</strong>（例子有Machine Check）；另一类的中断是由程序中执行了中断指令引起的，也称为<strong>软中断</strong>，由程序员通过INT或INT3指令触发，通常当做trap处理，可以用来实现<strong>系统调用</strong>；还有一类是外部设备(如输入输出设备)请求引起的中断，也称为<strong>外部中断或I&#x2F;O中断</strong>。这其中，外部中断可以进一步分为<strong>可屏蔽中断与不可屏蔽中断</strong>。</p><p>​还有一种分法是分为两类：<strong>中断和异常</strong>。中断是来自CPU以外的事件引起的中断（<strong>例子</strong>有I&#x2F;O中断、时钟中断、控制台中断），而异常来自CPU的内部事件或者由程序执行中的事件引起（例子有系统调用、缺页中断、双重错误）。</p><p>​</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a><a id="chapter4.1.3">异常的分类</a></h3><p>​<strong>相关问题：</strong></p><p>​第18题：异常的分类?（PPT里的标注疑似有问题，我改过来了）</p><p>答：异常可以分为三类：<strong>Fault，Trap和Abort</strong>，这可以根据<strong>eip寄存器中保存的值</strong>进行划分。</p><p>​Fault，是一种可被更正的异常，而且一旦被更正，程序可以不失连续性地继续执行。eip寄存器中所存储的返回地址是产生fault的指令的地址。Fault如果<strong>可以被修复就继续</strong>，否则会转化为终止，并进入下一步。</p><p>​Trap，一种在发生trap的指令执行之后立即被报告的异常，它也允许程序或任务不失连续性地继续执行。eip中所存储的返回地址是<strong>产生trap的指令之后的那条指令</strong>。Trap，顾名思义，是有意而为之的异常，是明知有套还往里钻，通常是可以被纠正的，其最常见的用途就是操作系统的系统调用。</p><p>​Abort，不总是报告精确异常发生位置的异常，不允许程序或任务继续执行，而是用来报告严重错误的。它是<strong>不可恢复的致命错误造成的结果</strong>，不能在eip中保存引起异常的指令所在的确切位置。终止处理程序将会<strong>将控制直接交给系统或者说是系统的终止应用程序</strong>而不是引发终止的引用程序。</p><h3 id="中断与异常的异同"><a href="#中断与异常的异同" class="headerlink" title="中断与异常的异同"></a><a id="chapter4.1.4">中断与异常的异同</a></h3><p>​<strong>相关问题：</strong></p><p>​第13题：中断与异常的区别? </p><p>​第21题：中断异常共同点（至少两点），不同点（至少三点）</p><p>答（这里按照21题的标准回答）（PPT上这个回答的语境中好像中断只是指外部中断）：</p><p>​<strong>相同点：</strong>中断和异常都是<strong>程序执行过程中的强制性转移</strong>，转移到相应的处理程序。它们都是软件或者硬件<strong>发生了某种情形而通知处理器</strong>的行为。</p><p>​<strong>不同点：</strong> </p><p>​<strong>第一</strong>，外部中断，是CPU所具备的功能。通常因为“硬件”而随机发生；而异常，是“软件”运行过程中的一种开发过程中没有考虑到的程序错误。</p><p>​<strong>第二</strong>，中断是CPU暂停当前工作，有计划地去处理其他的事情，中断的发生一般是可以预知的，处理的过程也是事先制定好的，处理中断时程序是正常运行的；而异常是CPU遇到了无法响应的工作，而后进入一种非正常状态，异常的出现表明程序存在缺陷。</p><p>​<strong>第三</strong>，从中断和异常的发生原因来看，中断是<strong>来自处理器外部的I&#x2F;O设备的信号</strong>的结果，它不是由指令流中某条指令执行引起的，从这个意义上讲，它是<strong>异步</strong>的，是来自指令流之外的；异常是执行当前指令流中的某条指令的结果，是来自指令流内部的，从这个意义上讲，异常都是<strong>同步</strong>的。</p><p>​<strong>第四</strong>，从<strong>返回点的角度</strong>来说，中断只是在正常的工作流之外执行额外的操作，之后继续做没做完的活，处理程序结束后返回到原指令流的下一条指令并继续执行；异常则有多种分类，trap和中断类似，处理程序结束后返回到原指令流的下一条指令并继续执行；对于<strong>可修复的fault</strong>，由于是在上一条指令执行过程中发生，因此修复fault后，会<strong>重新执行引发fault的指令</strong>；对于不可修复fault或者abort，则不会再返回。</p><p>​<strong>第五</strong>，中断是由于当前程序无关的中断信号触发的，CPU对中断的响应是被动的，且与CPU模式无关。既可以发生在用户态，又可以发生在核心态；异常是由CPU控制单元产生的，大部分异常<strong>发生在用户态</strong>。</p><p>​</p><h2 id="实模式下的中断处理"><a href="#实模式下的中断处理" class="headerlink" title="实模式下的中断处理"></a><a id="chapter4.2">实模式下的中断处理</a></h2><p>​<strong>相关问题</strong>：</p><p>​第1题：解释中断向量 </p><p>​第3题：解释中断向量表 </p><p>​第4题：实模式下中断程序地址如何得到？</p><p>​第6题：中断向量的地址如何得到? </p><p>​第7题：实模式下如何根据中断向量的地址得到中断程序地址? </p><p>​第20题：中断向量表中，每个中断有几个字节?里面的结构是什么?</p><h3 id="中断向量与中断向量表"><a href="#中断向量与中断向量表" class="headerlink" title="中断向量与中断向量表"></a><a id="chapter4.2.1">中断向量与中断向量表</a></h3><p>​<strong>相关问题</strong>：</p><p>​第1题：解释中断向量 </p><p>​第3题：解释中断向量表 </p><p>​第20题：中断向量表中，每个中断有几个字节?里面的结构是什么?</p><p>答：<strong>中断向量</strong>为<strong>4字节</strong>，存储相应的中断处理程序的起始地址（包括段基址和偏移量，<strong>低2字节为偏移量</strong>，<strong>高2字节为段地址</strong>）。</p><p>​中断向量表是8086系统内存中<strong>最低端1K字节空间</strong>，它的作用就是按照中断类型号从小到大的顺序存储<strong>共256个中断向量。</strong></p><h3 id="实模式下获取中断处理程序的入口"><a href="#实模式下获取中断处理程序的入口" class="headerlink" title="实模式下获取中断处理程序的入口"></a><a id="chapter4.2.2">实模式下获取中断处理程序的入口</a></h3><p>​<strong>相关问题</strong>：</p><p>​第4题：实模式下中断程序地址如何得到？</p><p>​第6题：中断向量的地址如何得到? </p><p>​第7题：实模式下如何根据中断向量的地址得到中断程序地址? </p><p>答（这里直接回答第4和第7题，顺带就能回答第6题）：</p><p>​首先由于中断向量是4个字节，通过<strong>中断向量号×4</strong>（因为中断向量表直接从地址为0开始，所以这里省去了加0）即可拿到存放中断向量的首地址。</p><p>​然后<strong>从低2字节得到偏移量，从高2字节得到处理例程的段地址</strong>。直接用实模式的寻址方式就能得到中断处理程序的入口地址。</p><h2 id="保护模式下的中断处理"><a href="#保护模式下的中断处理" class="headerlink" title="保护模式下的中断处理"></a><a id="chapter4.3">保护模式下的中断处理</a></h2><p>​<strong>相关问题：</strong></p><p>​第5题：保护模式下中断程序地址如何得到?</p><p>​第8题：解释中断描述符。</p><p>​第9题：保护模式下中断描述符表如何得到?</p><p>​第10题：保护模式下中断门如何得到? </p><p>​第11题：保护模式下如何根据中断门得到中断处理程序地址? </p><p>​第16题：IDT 是什么，有什么作用?</p><p>​第17题：IDT 中有几种描述符?</p><h3 id="中断描述符与IDT"><a href="#中断描述符与IDT" class="headerlink" title="中断描述符与IDT"></a><a id="chapter4.3.1">中断描述符与IDT</a></h3><p>​<strong>相关问题：</strong></p><p>​第8题：解释中断描述符。</p><p>​第16题：IDT 是什么，有什么作用?</p><p>​第17题：IDT 中有几种描述符?</p><p>答：<strong>中断描述符</strong>为连续的8个字节，描述<strong>保护模式</strong>下的异常和中断的处理例程的<strong>入口和相关属性</strong>，除了有段选择子（用于进一步取得段基址和限长）和偏移量外，还有许多属性和类型位（具体结构的图片和信息参见<a href="#chapter1.3.2.1">这里</a>）。</p><p>​<strong>IDT</strong>是保护模式下存储中断描述符的一种数据结构，其作用和实模式下的中断向量表类似。</p><p>​IDT中的中断描述符有3类：<strong>任务门、中断门和自陷门</strong>。</p><h3 id="保护模式下获取中断处理程序入口"><a href="#保护模式下获取中断处理程序入口" class="headerlink" title="保护模式下获取中断处理程序入口"></a><a id="chapter4.3.2">保护模式下获取中断处理程序入口</a></h3><p>​<strong>相关问题：</strong></p><p>​第5题：保护模式下中断程序地址如何得到?</p><p>​第9题：保护模式下中断描述符表如何得到?</p><p>​第10题：保护模式下中断门如何得到? </p><p>​第11题：保护模式下如何根据中断门得到中断处理程序地址? </p><p>答（直接回答第5题）：</p><p>​首先，我们先从<strong>IDTR</strong>寄存器中获取到中断描述符表对应的段基址和段限长，这就<strong>得到了中断描述符表</strong>。</p><p>​然后，我们用<strong>中断类型码×8</strong>得到相应的中断描述符的存储起始地址的偏移量，这就<strong>得到了中断类型码对应的中断门</strong>。</p><p>​最后，我们<strong>从中断门中得到段选择符和偏移量</strong>，<strong>以段选择符为段选择子</strong>，再根据第2位的情况，从GDT或LDT得到相应的段描述符，结合偏移量，<strong>得到相应中断处理程序的起始地址</strong>。</p><h2 id="实模式和保护模式下的中断处理的差别"><a href="#实模式和保护模式下的中断处理的差别" class="headerlink" title="实模式和保护模式下的中断处理的差别"></a><a id="chapter4.4">实模式和保护模式下的中断处理的差别</a></h2><p>​<strong>相关问题：</strong></p><p>​第14题：实模式和保护模式下的中断处理差别</p><p>答（这个问题PPT上没有，我试着概括了一下）：</p><p>​<strong>中断向量表&#x2F;IDT的获取</strong>：实模式下，中断向量表直接从0号地址开始；保护模式下，则要<strong>从IDTR中获取IDT</strong>。这也意味着IDT可以在内存空间中浮动。</p><p>​<strong>中断向量&#x2F;中断描述符的获取</strong>：实模式下，中断向量的地址只需要（用0加上）<strong>中断向量号×4</strong>即可得到，保护模式下则需要<strong>用IDT的起始地址加上中断类型码×8</strong>才能得到中断描述符。</p><p>​<strong>中断处理程序起始地址的获取</strong>：实模式下，只要拿到中断向量，即可从其高2字节得到段地址，低2字节得到偏移量，计算出中断处理程序的起始地址。保护模式下，拿到中断描述符后，还需要得到段选择子去进一步取出相应的段描述符，再根据门描述符给出的偏移量，得到中断处理程序的起始地址。</p><p>​中断处理的丰富化：实模式下，中断处理时只是跳转到对应的地址进行相应的处理，之后返回；保护模式下通过增加门，附带了更多信息，实现了更多的处理可能（实际上中断门和陷阱门的情况仍然和实模式差不多）。</p><p>​跳转过程的差别：保护模式有特权级的概念，跳转过程中可能会出现<strong>特权级检查和堆栈切换</strong>（可以参见<a href="#chapter1.3.1">这里</a>）。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a id="chapter4.5">其他</a></h2><h3 id="键盘组合键的识别"><a href="#键盘组合键的识别" class="headerlink" title="键盘组合键的识别"></a><a id="chapter4.5.1">键盘组合键的识别</a></h3><p>第15题：如何识别键盘组合键（如 Shift+a）是否还有其他解决方案?</p><p>答：ORANGE’S最后采取的方案是：对于扫描码，用全局数组存储Make Code对应的案件的相关值（可能是自己定义的宏），并设置缓冲区，若出现shift，control等按键，根据其break code与make code的情况，设置相应的标志位，用于与其他按键协作（利用位运算），之后进一步分析。</p><p>ORANGE’S之前提到的方案：设置一个或多个量存储一些特定的读到的值（比如shift）。</p><h3 id="用户态和内核态的特权级"><a href="#用户态和内核态的特权级" class="headerlink" title="用户态和内核态的特权级"></a><a id="chapter4.5.2">用户态和内核态的特权级</a></h3><p>第19题：用户态和内核态的特权级分别是多少? </p><p>答：用户态的特权级是3，内核态的特权级是0。</p><p><strong>To be continued…</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		如题，这也是个非常普通的随笔。和以往不同的是，这次我暂且并不是写好了再写blog的，所以中间或许有翻车的可能性。（5.8更新：昨天下午开始做这个项目之后越写越嗨，不小心就写完了，结果这篇还是马后炮。这里顺便感谢助教wbgg，感谢他多次解答了我关于这个项目的疑惑，至于相</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nasm拾遗</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/21438.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/21438.html</id>
    <published>2023-04-03T15:17:01.000Z</published>
    <updated>2023-04-05T15:23:40.180Z</updated>
    
    <content type="html"><![CDATA[<p>​如题，这篇帖子也就是在回看自己的代码和助教的PPT的时候标识一些有些容易忘记的内容，属于是想到哪写到哪，大概也没啥参考价值——版权声明我手动关了，这玩意谁爱搬谁搬——大概也不会有人看得上来搬运吧。顺便一提，这篇文章如果没特殊说明就是对32位汇编进行解释。</p><p>​4.5紧急添加：一些Lab1问题的整理。</p><p>​章节索引：</p><p>​        <a href="#hellonasm">1. Hello, nasm！</a></p><p>​<a href="#dx">1.1 以db为代表的dx</a></p><p>​<a href="#equAnd$">1.2 equ、$</a></p><p>​<a href="#global">1.3 global</a></p><p>​<a href="#label">1.4 标签</a></p><p>​<a href="#register">1.5 寄存器</a></p><p>​        <a href="#int80h">1.6 80h系统调用</a></p><p>​       <a href="#function">2. “函数”！</a></p><p>​<a href="#movinstruction">2.1 mov数据传送指令与解引用</a></p><p>​<a href="#jmpinstruction">2.2 jmp指令</a></p><p>​<a href="#pushpop">2.3 压栈与出栈</a></p><p>​<a href="#callinstruction">2.4 call指令与ret指令</a></p><p>​<a href="#parameter">2.5 参数传递？</a></p><p>​<a href="#loops">3. 分支和循环</a></p><p>​<a href="#cmpins">3.1 cmp比较指令</a></p><p>​<a href="#jzins">3.2 以jz为代表的一类跳转指令</a></p><p>​<a href="#addsub">3.3 add与sub</a></p><p>​<a href="#jzins">3.4 DIY一个循环体</a></p><p>​<a href="#lab1">4. Lab1问题整理</a></p><p>​<a href="#lab1.1">4.1 8086的寄存器（详细版本）</a></p><p>​<a href="#lab1.2">4.2 8086的段寄存器</a></p><p>​<a href="#lab1.3">4.3 8086的寻址方式（根据PPT整理）</a></p><p>​<a href="#lab1.4">4.4 主程序和子程序间的传参（根据PPT整理）</a></p><p>​<a href="#lab1.5">4.5 org07c00h伪指令</a></p><p>​<a href="#lab1.6">4.6 int 10h BIOS中断</a></p><p>​<a href="#lab1.7">4.7 times 510 - ($-$ $) db 0</a></p><p>​        <a href="#lab1.8">4.8 bochsrc诸参数</a></p><p>​<a href="#lab1.9">4.9 boot.bin放入的扇区</a></p><p>​<a href="#lab1.10">4.10 为何不让boot程序加载内核</a></p><p>​<a href="#lab1.11">4.11 Loader的作用</a></p><p>​<a href="#lab1.12">4.12 Kernel的作用</a></p><h1 id="Hello-nasm"><a href="#Hello-nasm" class="headerlink" title="Hello, nasm!"></a><a id="hellonasm">Hello, nasm!</a></h1><p>​虽然是想到哪写到哪，多少还是要组织一下文字，那还是找个好参(tou)照(lan)的东西，div的源码显然是不好放出来的，那就以PPT上的hello world作为开始吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">string: db &#x27;Hello World&#x27;, 0Ah</span><br><span class="line">length: equ $-string</span><br><span class="line">section .bss</span><br><span class="line">var: resb 1</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start:</span><br><span class="line">_start:</span><br><span class="line">mov eax, 4</span><br><span class="line">mov ebx, 1</span><br><span class="line">mov ecx, string</span><br><span class="line">mov edx, length</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">mov eax, 1</span><br><span class="line">mov ebx, 0</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure><p>​这里的section是一个<strong>伪指令</strong>，表示规划一段区域，.data, .bss, .text都是区域的代称。值得一提的是，使用<strong>jmp</strong>指令的时候，其指向的地址应当在代码区，也就是.text下面，如果指向其他区域的地址，会引发段错误，如果出现了段错误，可以考虑排查这个方面的问题（这是很容易出现的，尤其是用ide写时手动点回车点到个其他区域的<strong>标记</strong>）</p><h3 id="以db为代表的dx"><a href="#以db为代表的dx" class="headerlink" title="以db为代表的dx"></a><a id="dx">以db为代表的dx</a></h3><p>​.data区内的“变量”，是已经初始化的，比如第一个变量叫做string，db用在.data区，表示其存储单位是字节且是一个初始化了的量，这是一类单位，即“dx”，表示一个初始化的变量的基本单位，后面的x可以有多种表示，例如b就是字节，其他的如下图所示:</p><img src="/blogOfNoob.github.io/teawith/21438/xRefTo.jpg" class="" title="x代表什么？"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string: db &#x27;Hello World&#x27;, 0Ah</span><br><span class="line">length: equ $-string</span><br></pre></td></tr></table></figure><p>​再往下看，string应当是一个地址，或者我们用c语言的概念，不妨叫他char*，它指向一个字符串，叫’Hello World’，后面带上的<strong>0Ah</strong>对应的字符是换行符。</p><h3 id="equ、"><a href="#equ、" class="headerlink" title="equ、$"></a><a id="equAnd$">equ、$</a></h3><p>​下面这行又有个有趣的东西: equ 表示等于，不过实际上我们初始化一般的“变量“用不到它；这里后面跟了个表达式，$表示当前地址，-就是减，string就是上面声明的那个”变量“地址，这样我们得到了字符串的长度，这里也可以看出这些“变量”是<strong>顺序</strong>存放的。也就是说，我们上面的说法实质上并不准确，string这个<strong>标签</strong>并不会指向另外一块区域的字符串，这个字符串实际上就紧跟着这个地址接下来存储。事实上，我们这里只是给这个地址取名叫string，叫cat或是dog实际上也没有什么影响。</p><p>​.bss区内的“变量”是尚未初始化的，下一行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var: resb 1</span><br></pre></td></tr></table></figure><p>中的resb 表示保留以字节为单位的空间，后面跟上的是1。</p><p>​看上去似乎很简单，但实际上并不是这样的，假设我们有两个105字节保留空间的变量，比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testOne：resb 105</span><br><span class="line">testTwo: resb 105</span><br></pre></td></tr></table></figure><p>​当我们将这两个”变量“通过80h系统调用的读入进行初始化，且第一个放入的内容小于105字节时，再利用80h号系统调用，打印105字节长度的内容时，应该会发现会触及到第二个变量的区域内容，一个猜测是变量初始化后多保留的区域就被取消了。所以如果采用.bss区域的变量存储读入的字符串，一定要记得手动计算一下字符串的长度，这也方便填进<strong>int 80h</strong>系统调用的<strong>打印</strong>功能的edx寄存器。</p><h3 id="global"><a href="#global" class="headerlink" title="global"></a><a id="global">global</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start:</span><br><span class="line">_start:</span><br><span class="line">mov eax, 4</span><br><span class="line">mov ebx, 1</span><br><span class="line">mov ecx, string</span><br><span class="line">mov edx, length</span><br><span class="line">int 80h</span><br><span class="line"></span><br><span class="line">mov eax, 1</span><br><span class="line">mov ebx, 0</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure><p>​下面，终于进入.text区域，也就是代码区了，global将跟在它后面的<strong>标签</strong>标记为全局，从而将其名称添加到对象代码中，简单地说，它使得我们的汇编代码以其后的标记为“入口”——至少在Lab1，这样的认识已经足够了，在Lab1中，我们可以简单的把global后面的<strong>标签</strong>看作是main函数的入口。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a><a id="label">标签</a></h3><p>​之前提到了很多次”标签“，简单地说，标签就是给一个地址取一个自己想要的名字。事实上，这不仅对代码区的地址适用，在.data和.bss区域同样如此。上面提到过jmp一个非代码区的地址会出段错误——这说明这一步至少是过了编译的，也即，jmp一个”变量名“是合法的，而我们知道jmp指令后面跟着的是地址，所以这里的“变量名”就是一个地址。或者武断地讲，其实并没有什么“变量”，“变量名”连同“函数”一样，都只是某个地址的别名罢了，只不过为了解释方便，我们可以用“变量”或者“函数”来指代不同区域的标签指向的地址。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><a id="register">寄存器</a></h3><p>​接下来到了我们在后续的编程中相当需要依赖的内容之一，也就是寄存器了。</p><p>​我们当然有很多寄存器可以用，不过，要完成Lab1（Lab2我还没做到要用汇编的那一步），我们实际上只需要用到eax, ebx, ecx, edx这几个寄存器就能完成全部任务了，不过在这里还是解释一下寄存器们都是干啥的：</p><img src="/blogOfNoob.github.io/teawith/21438/register.jpg" class="" title="寄存器的大小"><p>​显然的，eax，edx，ecx与ebx都是32位的，也就是extended（大概吧，我瞎说的）；如果64位就是rax。ax寄存器指向eax的低16位，而ah是ax的高8位，al是ax的低8位。当然，这几个寄存器的功能并不完全一样，我查到的结果是：</p><p>​eax 是累加器(accumulator), 它是很多加法乘法指令的缺省寄存器；</p><p>​ebx 是基地址(base)寄存器, 在内存寻址时存放基地址；</p><p>​ecx是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器；</p><p>​edx 则总是被用来放整数除法产生的余数。</p><p>​不过我们似乎不需要管这些，大数除法的实现并不一定要用到mul和div两种指令，edx就给解放出来了，ebx我实际用下来乱放数据好像没影响，loop和rep似乎也用不到（想压行的例外）。更何况我们在Lab1中进行数学运算的数据8位足矣（参与运算的最大数值是字符串长度你敢信？），用32位多少有点大材小用。</p><p>​esi与edi寄存器好像是源和目的索引寄存器，不过暂且用不到，Lab1里面我们用abcd四个数据寄存器能开16个8位的暂存空间，根本用不到这俩寄存器。</p><p>​一些以s结尾的寄存器是段寄存器，但实际上只要我们代码别写太长，应该用不到。</p><p>​下面还有两个esp和ebp，顾名思义，ebp一直指向栈底，esp一直指向栈顶。Lab1我们仍然没必要用到他们，不过在Lab2我们就不得不用了——在Lab2，我们不能那么自由的操纵寄存器了，到那时，我们可以关注一下一般情况下的函数传参。</p><p>​这里的解释并不完全详细，详细的解释跳转</p><h3 id="80h系统调用"><a href="#80h系统调用" class="headerlink" title="80h系统调用"></a><a id="int80h">80h系统调用</a></h3><p>​int 80h很复杂。简单地说，eax固定存储系统调用号，而其他寄存器存储相关参数。</p><p>​我们只需要用到三种：eax置1、eax置3与eax置4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">mov ebx, 0</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure><p>​先来看看最简单的eax置1，也就是exit，这个系统调用应该没啥说的，就是退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 3</span><br><span class="line">mov ebx, 0</span><br><span class="line">mov ecx, string</span><br><span class="line">mov edx, lengthone</span><br><span class="line">int 80h</span><br><span class="line">mov eax, 4</span><br><span class="line">mov ebx, 1</span><br><span class="line">mov ecx, string</span><br><span class="line">mov edx, lengthone</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure><p>​eax置3和eax置4我们不妨放在一起看。3表示读，4表示写。ebx中放的貌似是表示哪一种io流，反正按图中这种写法总归没问题。ecx放置的是一个地址，用于存储读入或是要写的字符串，edx放置读或写的长度。值得一提的是，在读的时候，虽然我们规定了长度，但实际上如果我们没有输入比edx中长度更长的字符串，读取内容也是到我们敲下回车为止，仅此而已。关于IO的部分我后面可能会再展开写一点。</p><p>​到这里为止，我们分析完了一开始给出的hello world代码，就这一部分，我们居然写了两千多个词，不过好消息是，我们知道了db、resb的含义，int 80h系统调用的一些知识，以及对寄存器有了一些初步的了解。</p><h1 id="“函数”"><a href="#“函数”" class="headerlink" title="“函数”!"></a><a id="function">“函数”!</a></h1><p>​现在我们完成了hello world的书写，不过到此就满足了吗？比如说这次大数除法，我们的读和写要调用两次，可能中间还有一些测试需求需要打印一些信息，为此，我们可以考虑进行“函数”的封装，实现代码段的反复使用。</p><p>​还是来看看PPT给出的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SECTION .data</span><br><span class="line">msg     db      &#x27;Hello, brave new world!&#x27;, 0Ah</span><br><span class="line"> </span><br><span class="line">SECTION .text</span><br><span class="line">global  _start</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">    mov     eax, msg        </span><br><span class="line">    call    strlen          </span><br><span class="line"> </span><br><span class="line">    mov     edx, eax        </span><br><span class="line">    mov     ecx, msg</span><br><span class="line">    mov     ebx, 1</span><br><span class="line">    mov     eax, 4</span><br><span class="line">    int     80h</span><br><span class="line"> </span><br><span class="line">    mov     ebx, 0</span><br><span class="line">    mov     eax, 1</span><br><span class="line">    int     80h</span><br><span class="line">    </span><br><span class="line">;; strlen(str: eax)-&gt;len: eax</span><br><span class="line">strlen:                     </span><br><span class="line">    push    ebx</span><br><span class="line">    mov     ebx, eax</span><br><span class="line"> </span><br><span class="line">nextchar:</span><br><span class="line">    cmp     byte [eax], 0</span><br><span class="line">    jz      finished</span><br><span class="line">    inc     eax</span><br><span class="line">    jmp     nextchar</span><br><span class="line"> </span><br><span class="line">finished:</span><br><span class="line">    sub     eax, ebx</span><br><span class="line">    pop     ebx </span><br><span class="line">    ret                   </span><br></pre></td></tr></table></figure><h3 id="mov数据传送指令与解引用"><a href="#mov数据传送指令与解引用" class="headerlink" title="mov数据传送指令与解引用"></a><a id="movinstruction">mov数据传送指令与解引用</a></h3><p>​在开始接下来的分析之前，我们不妨先看看数据传送指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx</span><br><span class="line">mov bl, 1</span><br><span class="line">mov bh, byte[getfrom]</span><br><span class="line">mov dword[fillin], ecx</span><br><span class="line">mov cl, byte[edx]</span><br></pre></td></tr></table></figure><p>​这里列出了mov的一些用法。其核心格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dest, src</span><br></pre></td></tr></table></figure><p>​第一种是将ebx寄存器中的内容mov给eax；第二种是将bl中置为1。到第三种这里出现了解引用**[]**，其含义是，对于方框中的地址，用方框前的变量将其取出，也就是说，第三种将getfrom这个地址的一个字节取出。第四种将ecx中的32位数据存到fillin这个地址处。既然方框中放置一个地址，那么第五种也是可以成立的，即将edx指向的地址以字节方式取出放到cl中。</p><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a><a id="jmpinstruction">jmp指令</a></h3><p>​前文我们提到了很多次<strong>jmp指令</strong>，事实上，这个指令对于我们的编程有着重要的作用——比如用一些简单的指令实现循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp LABLE_LOOP</span><br></pre></td></tr></table></figure><p>​jmp指令的格式相当简单，指令名称之后就是一个地址，当然我们有偷懒的方法，比如使用<strong>标签</strong>减少自己的计算。然而，jmp有其局限性，比如如果需要跳回来。我们当然可以跳来跳去，但是系统给我们提供了更集成和智能的指令——call和ret。</p><h3 id="压栈与出栈"><a href="#压栈与出栈" class="headerlink" title="压栈与出栈"></a><a id="jmpinstruction">压栈与出栈</a></h3><p>​在正式进入call与ret之前，我们还需要补上一点内容，那就是栈。基本的概念之前的课都涉及到了我再搬一遍也没意思，直接看指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push edx</span><br><span class="line">pop eax</span><br></pre></td></tr></table></figure><p>​栈和我们选用的系统息息相关，在32位编译下，上述写法是合法的，而若以64位进行编译，则会在编译时出错，需要改用rdx与rax。</p><p>​实际上，这两个指令并不只做一件事，他们除了将相关的值压栈和出栈之外，还修改了栈指针寄存器（ESP），将edx压栈之后，esp的内容增加4，为什么是加4呢？这是因为32位编译下，我们向栈中压入了32位，即4个字节的内容，故而加4。同样的逻辑下，当我们修改一块以db为单位的存储空间——姑且认为是一个byte数组时，我们存地址的寄存器每次即加1。</p><p>​32位下据说有两个非常棒的指令pusha和popa，不过我没怎么用，就不误人子弟了。</p><h3 id="call指令与ret指令"><a href="#call指令与ret指令" class="headerlink" title="call指令与ret指令"></a><a id="callinstruction">call指令与ret指令</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call strlen</span><br><span class="line">;do something</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>​call指令的格式同样相当简单。它的功能是，如果要段间跳转，就将call的<strong>下一条</strong>指令的段基址（存于CS）和相对偏移(存于IP寄存器，也即指令指针寄存器)入栈，如果是段内跳转，则只将相对偏移（存于IP寄存器）入栈；接下来执行jmp命令的功能。ret的作用恰好相反，将对应的值出栈并存储到相应寄存器中。这样在ret之后，我们就能执行call指令之后的指令。</p><p>​由于系统已经给我们包装好了相关功能，所以如果我们要实现“函数”调用，那就直接用call和ret就可以了。</p><h3 id="参数传递？"><a href="#参数传递？" class="headerlink" title="参数传递？"></a><a id="parameter">参数传递？</a></h3><p>​前文说过，汇编里面其实所谓的“变量”和“函数”都是标签，前面也解释了call指令和ret指令，其实非常简单，这就引出了一个问题，我们该怎么进行参数传递？</p><p>​汇编代码是极度自由的，这体现在我们可以自由地操纵大多数寄存器，以ppt中这个函数为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;; strlen(str: eax)-&gt;len: eax</span><br><span class="line">strlen:                     </span><br><span class="line">    push    ebx</span><br><span class="line">    mov     ebx, eax</span><br><span class="line"> </span><br><span class="line">nextchar:</span><br><span class="line">    cmp     byte [eax], 0</span><br><span class="line">    jz      finished</span><br><span class="line">    inc     eax</span><br><span class="line">    jmp     nextchar</span><br><span class="line"> </span><br><span class="line">finished:</span><br><span class="line">    sub     eax, ebx</span><br><span class="line">    pop     ebx </span><br><span class="line">    ret     </span><br></pre></td></tr></table></figure><p>​注释写的算是比较明白的了，我们在eax中放置一个地址——这里它的意义是一个字符串的起始地址，那么我们所需要做的就是在“函数调用“之前往我们设定好的”函数“的对应寄存器中存入参数即可。这种参数传递在我们只写汇编的时候非常舒服。</p><p>​那么如果我们用高级语言函数调用汇编的代码时，怎么办呢？之前学习高级语言时，我们知道函数调用时也会发生参数压栈，所以我们可以用栈指针寄存器减去一定的数值来获取相关参数，不过压栈的顺序我不是很清楚（还没做到），故而在此就暂且不说了。</p><p>​我们只写汇编时还有一种暴力的传参手段，就是直接在.bss区开个变量临时存值，但是这样就会增加访存次数，造成时间消耗增大，不过在这里影响暂且不大。</p><h1 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a><a id="loops">分支和循环</a></h1><p>​到上面为止，我们应该是把函数调用讲了个七七八八，不过我们还没有仔细看这个strlen函数是怎么实现的呢，接下来，我们刚好借着这些新指令来顺便看一看如何用已有的汇编指令实现简单的循环和分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;; strlen(str: eax)-&gt;len: eax</span><br><span class="line">strlen:                     </span><br><span class="line">    push    ebx</span><br><span class="line">    mov     ebx, eax</span><br><span class="line"> </span><br><span class="line">nextchar:</span><br><span class="line">    cmp     byte [eax], 0</span><br><span class="line">    jz      finished</span><br><span class="line">    inc     eax</span><br><span class="line">    jmp     nextchar</span><br><span class="line"> </span><br><span class="line">finished:</span><br><span class="line">    sub     eax, ebx</span><br><span class="line">    pop     ebx </span><br><span class="line">    ret     </span><br></pre></td></tr></table></figure><h3 id="cmp比较指令"><a href="#cmp比较指令" class="headerlink" title="cmp比较指令"></a><a id="cmpins">cmp比较指令</a></h3><p>​无论是高级语言中的if还是while还是for，都离不开<strong>比较</strong>。在汇编里，比较可以用<strong>cmp</strong>指令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, ebx</span><br><span class="line">cmp dl, byte[toCmp]</span><br><span class="line">cmp dh, 100</span><br></pre></td></tr></table></figure><p>​cmp指令后跟上两个待比较的<strong>位数相同</strong>的内容。比较的结果并不放在寄存器中，而是影响CPU中的FLAG，那么我们该怎么访问到这些FLAG呢？系统同样给了我们大量的现成指令，这就是以jz为代表的一类跳转指令。</p><h3 id="以jz为代表的一类跳转指令"><a href="#以jz为代表的一类跳转指令" class="headerlink" title="以jz为代表的一类跳转指令"></a><a id="jzins">以jz为代表的一类跳转指令</a></h3><p>​jz的意思是，如果ZERO FLAG被设置（set），则进行跳转，以无符号数的比较为例，我们有以下这些跳转指令：</p><img src="/blogOfNoob.github.io/teawith/21438/unsignedcmp.jpg" class="" title="无符号下的跳转指令"><p>​实际上，对于Lab1来说，无符号数和有符号数差别不大，ja与jna换成了jg和jng，jb与jnb换成了jl和jnl，用哪个问题都不大。</p><p>​至此，我们有了比较和跳转，可以着手实现一个简单的分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp al, 10</span><br><span class="line">jz LABEL_OUT</span><br><span class="line">;do something</span><br><span class="line"></span><br><span class="line">LABEL_OUT:</span><br><span class="line">;do some other things</span><br></pre></td></tr></table></figure><p>​这就是一个简单的<strong>分支</strong>了，依据我们的需要，可以往里面加入不同的代码。</p><h3 id="add与sub"><a href="#add与sub" class="headerlink" title="add与sub"></a><a id="addsub">add与sub</a></h3><p>​add和sub，顾名思义，一个加，一个减，他们的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add dest, src</span><br><span class="line">sub dest, src</span><br></pre></td></tr></table></figure><p>​对于add，结果为dest &#x3D; dest + src, 结果存在dest对应的寄存器中，dest只能是一个寄存器。减法同理。</p><p>​有了加和减，实现类似for循环也不是什么难事了，在此之前，还有两个实用（省打字数目）的指令：inc与dec：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc eax</span><br><span class="line">dec bh</span><br></pre></td></tr></table></figure><p>​这两个指令顾名思义，是进行自增和自减的指令，使其后寄存器中的值每次”增加“或”减少“1。</p><h3 id="DIY一个循环体"><a href="#DIY一个循环体" class="headerlink" title="DIY一个循环体"></a><a id="jzins">DIY一个循环体</a></h3><p>​现在我们有了四个实用的指令：比较指令用于判断是否满足退出循环的条件，条件跳转指令实行判断满足条件后的跳转，无条件跳转指令实现回环往复，add和sub这一类指令实现更新——当然绝不止这两个指令能实现这一要求。</p><p>​我们可以先搭一个最简单的循环，也就是死循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL_LOOP:</span><br><span class="line">;do something</span><br><span class="line">jmp LABEL_LOOP</span><br></pre></td></tr></table></figure><p>​接下来我们要着手跳出循环了，我们以将al中的值（不妨初始化为0）和10比较，如果相等作为跳出循环的条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0</span><br><span class="line">LABEL_LOOP:</span><br><span class="line">cmp al, 10</span><br><span class="line">jz LABEL_OUT_LOOP</span><br><span class="line">;do something</span><br><span class="line">jmp LABEL_LOOP</span><br><span class="line"></span><br><span class="line">LABEL_OUT_LOOP:</span><br><span class="line">;do some other things</span><br></pre></td></tr></table></figure><p>​最后如果我们想让他执行10步（11次比较），则将增量设置为1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0</span><br><span class="line">LABEL_LOOP:</span><br><span class="line">cmp al, 10</span><br><span class="line">jz LABEL_OUT_LOOP</span><br><span class="line">inc al</span><br><span class="line">;do something</span><br><span class="line">jmp LABEL_LOOP</span><br><span class="line"></span><br><span class="line">LABEL_OUT_LOOP:</span><br><span class="line">;do some other things</span><br></pre></td></tr></table></figure><p>​至此，一个简单的循环体搭建完毕。</p><p>​事实上，考虑另外一种方法，也即我们之前写的<strong>分支</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp al, 10</span><br><span class="line">jz LABEL_OUT</span><br><span class="line">;do something</span><br><span class="line"></span><br><span class="line">LABEL_OUT:</span><br><span class="line">;do some other things</span><br></pre></td></tr></table></figure><p>​只需要在不满足条件时进行自增及反复回跳即可做到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov al, 0</span><br><span class="line">LABEL_LOOP:</span><br><span class="line">cmp al, 10</span><br><span class="line">jz LABEL_OUT_LOOP</span><br><span class="line">inc al</span><br><span class="line">;do something</span><br><span class="line">jmp LABEL_LOOP</span><br><span class="line"></span><br><span class="line">LABEL_OUT_LOOP:</span><br><span class="line">;do some other things</span><br></pre></td></tr></table></figure><p>​有了这个简单的小循环体，我们能做很多事，比如实现之前的strlen，甚至我们可以用80h系统调用中进行写的方法实现一个经典的getchar直到特定字符。</p><h1 id="Lab1问题整理"><a href="#Lab1问题整理" class="headerlink" title="Lab1问题整理"></a><a id="lab1">Lab1问题整理</a></h1><h3 id="8086的寄存器（详细版本）"><a href="#8086的寄存器（详细版本）" class="headerlink" title="8086的寄存器（详细版本）"></a><a id="lab1.1">8086的寄存器（详细版本）</a></h3><p>8086有哪5类寄存器？请分别举例说明其作⽤。 </p><p>参考来源：<a href="https://zhuanlan.zhihu.com/p/115915986">x86汇编之——8086寄存器讲解 - 知乎 (zhihu.com)</a></p><p>答：分为数据寄存器（ax,bx,cx, dx）、指针寄存器(sp, bp)、变址寄存器(si-source index, di-destination index)、控制寄存器(flag, ip-instruction pointer)、段寄存器(cs-code segment, ds-data segment, es-extra segment, ss-stack segment)</p><p>通用寄存器中：</p><p>数据寄存器：</p><p>ax:累加器，在通用的暂存数据以外的作用有比如存16位乘法的低位结果。</p><p>bx:除了通用功能外，还有专属功能寻址，作为一种<strong>基址</strong>寄存器。</p><p>cx：计数器，除了通用功能还能配合loop指令。</p><p>dx：除了通用功能，还能存除法结果的高位。</p><p>指针寄存器：</p><p>sp：stack pointer，指向栈顶（确切地说存了偏移量）。</p><p>bp: base pointer，指向栈底（确切地说存的是偏移量）。</p><p>变址寄存器：</p><p>si：源变址寄存器</p><p>di：目的变址寄存器</p><p>这俩作为通用寄存器当然可以暂存数据，但主要的功能还是存放地址偏移，配合相关的段寄存器进行寻址。</p><p>控制寄存器：</p><img src="/blogOfNoob.github.io/teawith/21438/registers.jpg" class="" title="flag寄存器"><p>FLAG寄存器中，一部分是和比较结果有关的，其他和一些别的功能有关。</p><p>IP 指令指针寄存器，常配合CS寄存器进行指令的取出。</p><p>段寄存器：见下文</p><h3 id="8086的段寄存器"><a href="#8086的段寄存器" class="headerlink" title="8086的段寄存器"></a><a id="lab1.2">8086的段寄存器</a></h3><p>有哪些段寄存器，它们的作⽤是什么？ </p><p>答：</p><p>CS：代码段寄存器，配合IP寄存器指向需要执行的指令。</p><p>DS：数据段寄存器</p><p>ES：附加段寄存器</p><p>上面这两个都可以用来配合数据寻址。</p><p>SS：堆栈段寄存器：SS:BP 指向栈底，SS:SP指向栈顶</p><h3 id="8086的寻址方式（根据PPT）"><a href="#8086的寻址方式（根据PPT）" class="headerlink" title="8086的寻址方式（根据PPT）"></a><a id="lab1.3">8086的寻址方式（根据PPT）</a></h3><p>什么是寻址？8086有哪些寻址⽅式？ </p><p>答：寻址就是找到操作数的地址。</p><p>8086的寻址方式有： 立即寻址、直接寻址、寄存器寻址、寄存器间接寻址、寄存器相对寻址 、基址加变址、相对基址加变址</p><p>具体来说：立即寻址就是直接在操作数中给出值，直接寻址是在操作数中给出地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 10;这是立即寻址</span><br><span class="line">mov ax, word[1234H];这是直接寻址</span><br></pre></td></tr></table></figure><p>寄存器寻址将操作数放在寄存器中，而寄存器间接寻址将操作数的地址置于寄存器中，寄存器相对寻址使寄存器中的地址加上一个立即数得到真正的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, bx;这是寄存器寻址</span><br><span class="line">mov ax, word[bx];这是寄存器间接寻址</span><br><span class="line">mov ax, word[si + 3];这是寄存器相对寻址</span><br></pre></td></tr></table></figure><p>基址加变址的操作方法是将基址寄存器（BX, BP）中的地址加上变址寄存器（SI, DI）的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, word[bx + di];这是基址加变址</span><br></pre></td></tr></table></figure><p>相对基址加变址还存在额外偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, word[bx + di + 3]</span><br></pre></td></tr></table></figure><h3 id="主程序和子程序间的传参（根据PPT）"><a href="#主程序和子程序间的传参（根据PPT）" class="headerlink" title="主程序和子程序间的传参（根据PPT）"></a><a id="lab1.4">主程序和子程序间的传参（根据PPT）</a></h3><p>主程序与⼦程序之间如何传递参数？ </p><p>答：有以下几种：</p><p>通过寄存器传参（向寄存器中置入我们想要传递的参数）；</p><p>通过约定的地址传参；</p><p>以及通过堆栈传参：利用栈指针寄存器等拿到堆栈中的值（或者确知无风险的情况下采用pop）。</p><h3 id="伪指令-org07c00h"><a href="#伪指令-org07c00h" class="headerlink" title="伪指令 org07c00h"></a><a id="lab1.5">伪指令 org07c00h</a></h3><p>解释 boot.asm ⽂件中 org 07c00h 的作⽤。如果去掉这⼀句，整个程序应该怎么修改？ </p><p>答：org本身并不会把代码段放在07c00h处（放在这是BIOS干的），它只是告诉编译器，这个代码段会放在这，这样编译器就会把绝对地址自动加上07c00h。如果去掉这一句，我们就需要在所有<strong>直接给出的</strong>相对地址后面手动加上07c00h:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, bootMessage + 07c00h</span><br></pre></td></tr></table></figure><h3 id="int-10h-BIOS中断"><a href="#int-10h-BIOS中断" class="headerlink" title="int 10h BIOS中断"></a><a id="lab1.6">int 10h BIOS中断</a></h3><p>解释 int 10h 的功能。 </p><p>参考来源：<a href="https://blog.csdn.net/hua19880705/article/details/8125706">汇编中的10H中断int 10h详细说明_hua19880705的博客-CSDN博客</a></p><p>答：汇编中的10h 中断是由BIOS对显示器和屏幕所提供的服务程序。使用int 10h服务程序时，必须先指定ah寄存器为显示服务编号之一，以指定需要调用的功用。</p><p>以boot.asm中出现的ah置013h为例，其功能是：在Teletype模式下显示字符串。</p><p>bh置入页码，bl置入属性，具体来说是底色和字色。cx置入字符串长度。dh与dl分别置入行列坐标。</p><p>al置入显示输出方式，具体来说：</p><p>0—— 字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</p><p>1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</p><p>2 ——字符串中含显示字符和显示属性。显示后，光标位置不变</p><p>3——字符串中含显示字符和显示属性。显示后，光标位置改变</p><h3 id="times-510-db-0"><a href="#times-510-db-0" class="headerlink" title="times 510 - ($-$ $) db 0"></a><a id="lab1.7">times 510 - ($-$ $) db 0</a></h3><p>解释 boot.asm ⽂件中 times 510-($-$$) db 0 的作⽤。 </p><p>答：times表示重复汇编，在times后面跟着的表达式会被重复指定的次数。</p><p>510 -($-$$) 就是这个被指定的次数，$表示当前行被汇编后的地址，而$$表示当前段开始处被汇编后的的地址。</p><p>db 0 表示存入0。</p><p>综上所述，这个指令的作用就是填满到510为止的空间。</p><p>下一行再加上魔数（0xaa55，也就是结束标志），这样刚好512字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">times 510-($-$$)db0; 填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">dw 0xaa55; 结束标志</span><br></pre></td></tr></table></figure><h3 id="bochsrc诸参数"><a href="#bochsrc诸参数" class="headerlink" title="bochsrc诸参数"></a><a id="lab1.8">bochsrc诸参数</a></h3><p>解释 bochsrc 中各参数的含义。 </p><p>答：我们写的配置文件是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">megs:32</span><br><span class="line">display_library: sdl2 </span><br><span class="line">floppya: 1_44=a.img, status=inserted</span><br><span class="line">boot: floppy</span><br></pre></td></tr></table></figure><p>megs表示虚拟机内存大小（32即32MB）；display_library表示采用的图形库，这里填sdl2即采用sdl2库；boot表示虚拟机启动方式，floppy表示从软盘启动；floppya是虚拟机外设，确切地说，规范了第一个驱动该是啥，这里的参数中1_44是软盘媒体类型，status &#x3D; inserted表示初始状态是插入，简单来说这个语句就是以a.img为软盘文件。</p><h3 id="boot-bin放入的扇区"><a href="#boot-bin放入的扇区" class="headerlink" title="boot.bin放入的扇区"></a><a id="lab1.9">boot.bin放入的扇区</a></h3><p>boot.bin 应该放在软盘的哪⼀个扇区？为什么？ </p><p>答：放在第0磁头第0磁道第1扇区。</p><p>原因：计算机开机启动后，首先经过BIOS开机自检，检查硬件设备是否有问题，如果没有，将会根据BIOS 的启动项配置选择引导设备，我们选择的是从软盘启动。于是接下来BIOS检测第0磁头第0磁道第1扇区是否以0xaa55结束，如果是，即认为这是引导扇区，将他放在7c00h处，并将处理器执行权交给这段程序。故而boot.bin需要放在第0磁头第0磁道第1扇区。</p><h3 id="为何不让boot程序直接加载内核"><a href="#为何不让boot程序直接加载内核" class="headerlink" title="为何不让boot程序直接加载内核"></a><a id="lab1.10">为何不让boot程序直接加载内核</a></h3><p>为什么不让Boot程序直接加载内核，⽽需要先加载Loader再加载内核？</p><p>答：boot程序受到512字节的限制，而我们在加载内核时还需要做很多其他事——比如设置保护模式。应该说512字节远远不够，所以要先加载Loader，将控制权交给他，再由loader加载内核。</p><h3 id="Loader的作用"><a href="#Loader的作用" class="headerlink" title="Loader的作用"></a><a id="lab1.11">Loader的作用</a></h3><p> Loader的作⽤有哪些？ </p><p>答：Loader的作用主要有：</p><p>跳入保护模式（从而才得以访问1M以上的内存）；</p><p>启动内存分页；</p><p> 从kernel.bin中读取内核，并放入内存，然后跳转到内核所在的开始地址，运行内核。（查找方式和boot查找loader时类似，不过由于我们实验中的kernel是在操作系统层面下编写的，存在一些无关信息，所以需要loader来提取需要放入内存的部分）</p><h3 id="Kernel的作用"><a href="#Kernel的作用" class="headerlink" title="Kernel的作用"></a><a id="lab1.12">Kernel的作用</a></h3><p>Kernel的作⽤有哪些？</p><p>答：这是真正的操作系统，其中的内核具有内存管理，进程调度，图像显示，网络访问等功能。</p><p><strong>To be continued…</strong></p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		如题，这篇帖子也就是在回看自己的代码和助教的PPT的时候标识一些有些容易忘记的内容，属于是想到哪写到哪，大概也没啥参考价值——版权声明我手动关了，这玩意谁爱搬谁搬——大概也不会有人看得上来搬运吧。顺便一提，这篇文章如果没特殊说明就是对32位汇编进行解释。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OSLab2随笔</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/35904.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/35904.html</id>
    <published>2023-04-02T16:51:17.000Z</published>
    <updated>2023-04-27T12:31:55.438Z</updated>
    
    <content type="html"><![CDATA[<p>​做完Lab2，其实感觉还是很有成就感的，但这“火箭”造的说实话不是很友好。好消息是，某位助教的ppt里面的一个参考来源有相当有价值的内容和代码：<a href="https://blog.csdn.net/qq_39654127/article/details/88429461">FAT12文件系统详解（CSDN）</a>，能给我们不少帮助——当然，核心部分还是得我们自己写。</p><p>​我是个懒人，而且自认代码写的不咋地，这篇帖子里面大段源码是没有的（那个CSDN的已经很有用了，那部分得自己想，说出来就没意思了）。一些坑我可能也不会都写下来——多数大概还是会以谜语人的形式出现（除了明面上的谜语以外，也请注意任何加粗的字），可能ddl之前几天我会重新回来改写这些谜语——不过也有可能不会，纯看心情和事多不多——现在软工二的任务感觉也麻烦起来了。</p><p>​那么，让我们开始这次的胡言乱语吧！</p><p>​4.11日更新：一个有一点用，但用处不多的reference：<a href="https://cs.nyu.edu/~gottlieb/courses/os202/kholodov-fat.html#F01_0270_deleting">The FAT File System (nyu.edu)</a>。</p><p>​4.15日问答更新：备注：<strong>最后两题</strong>不确定。</p><p>​<a href="#chapter1">1. 似曾相识燕归来</a></p><p>​<a href="#chapter1.1">1.1 文件读取</a></p><p>​<a href="#chapter1.2">1.2 pragma</a></p><p>​<a href="#chapter1.3">1.3 读取FAT12表</a></p><p>​<a href="#chapter2">2. “打开”目录项</a></p><p>​<a href="#chapter2.1">2.1 数据区的文件夹</a></p><p>​<a href="#chapter2.2">2.2 LFN项的产生</a></p><p>​<a href="#chapter2.3">2.3 目录项动态变化简析</a></p><p>​<a href="#chapter3">3. 最后几块砖</a></p><p>​<a href="#chapter3.1">3.1 早已完成的cat</a></p><p>​<a href="#chapter3.2">3.2 ls命令与-l选项</a></p><p>​<a href="#chapter3.3">3.3 函数传参与联合编译</a></p><p>​<a href="#chapter4">4 Lab2问答</a></p><p>​<a href="#chapter4.1">4.1 实模式与保护模式</a></p><p>​<a href="#chapter4.2">4.2 选择子</a></p><p>​<a href="#chapter4.3">4.3 描述符</a></p><p>​<a href="#chapter4.4">4.4 GDT与LDT</a></p><p>​<a href="#chapter4.5">4.5 GDTR与LDTR</a></p><p>​<a href="#chapter4.6">4.6 GDT查找物理地址</a></p><p>​<a href="#chapter4.7">4.7 LDT查找物理地址</a></p><p>​<a href="#chapter4.8">4.8 根目录区相关问答</a></p><p>​<a href="#chapter4.9">4.9 数据区的第一个簇号</a></p><p>​<a href="#chapter4.10">4.10 FAT表的作用</a></p><p>​<a href="#chapter4.11">4.11 静态链接的过程</a></p><p>​<a href="#chapter4.12">4.12 动态链接的过程</a></p><p>​<a href="#chapter4.13">4.13 ld vs gcc</a></p><p>​<a href="#chapter4.14">4.14 Linux下可执行文件的虚拟地址空间</a></p><h1 id="似曾相识燕归来"><a href="#似曾相识燕归来" class="headerlink" title="似曾相识燕归来"></a><a id="chapter1">似曾相识燕归来</a></h1><p>​在讨论FAT12文件系统的相关细节之前，我们有一些可以马上做的事情——比如对输入做一部分解析，至少我们应该可以鉴别出三种命令（其中ls有一个可选项）。在这一步，我们甚至并不需要去解析地址，只需要注意甄别各种对的错的-l就行了。输入的处理我就不多写了，这一部分实在是平淡无味。</p><p>​完成这一步的处理后，在进一步规划具体实现前，我们不妨先看看参考资料：<a href="https://blog.csdn.net/qq_39654127/article/details/88429461">FAT12文件系统详解（CSDN）</a>。当看到目录时，似乎突然眼前一黑：<img src="/blogOfNoob.github.io/teawith/35904/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E7%9B%AE%E5%BD%95.jpg" class="" title="参考资料目录"></p><p>​这不就是我们Lab1做过的事情之一吗？</p><p>​确实如此，事实上，回顾一下，我们Lab1也做了很多可以直接用到Lab2的工作，比如说，Lab1为了寻找LOADER，我们编(c)写(v)了读取根目录区并比对文件或文件夹名称的代码。为了读取LOADER，我们也有配合FAT12表项读取软盘相应内容的代码——甚至支持读取超过512字节的内容。看上去，直接用汇编继续写Lab2似乎也没那么难——只要我们能解决文件读取以及读取数据区的目录项的技术问题——实际上严格来说比较全新的也就是文件读取了。然而，这个不在本篇帖子的讨论范围之内，有想卷分的大佬可以去做。</p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a><a id="chapter1.1">文件读取</a></h3><p>​这个引用的CSDN帖子中的文件读取用到了QFile这个类，不过我们没有必要这么麻烦。c++自带一个fstream类用于处理文件流，当然了，这个类并没有readRawData这个函数，不过有一个功能类似的，此外还有一个和seek功能相似的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream in;</span><br><span class="line">in.<span class="built_in">seekg</span>(<span class="number">3</span>);</span><br><span class="line">in.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(myPointer), <span class="built_in">sizeof</span>(myPtr));</span><br></pre></td></tr></table></figure><p>​值得一提的是，文章中这个方法到fstream里面换了个函数依然能用，通过将原来的指针重新映射为char*类型的，配合read函数，从而可以无脑地接受以字节流形式传入的数据。</p><h3 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a><a id="chapter1.2">pragma</a></h3><p>​当然，如果你搬东西的时候漏了一些代码，可能试着打印相关内容的时候会“惊喜”地发现一些值和预期的值并不一样，那么可以多打印几个值，看看用于存放boot数据区或者entry目录项的结构体中某些变量是不是存放了本来不应该属于他们的值——比如后面几个变量的值，甚至更不幸地，是两个变量各出了一部分应得的值。是的，警惕编译时的对齐操作——不过我们当然也有方法对抗默认的对齐，比如说:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="comment">//our struct</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure><p>​<strong>#pragma</strong>可以用来指示编译器完成一些特定的动作，而pack就是和内存对齐相关的。push和pop有点类似于栈操作中的意思，到push时，之前的状态将被保存，到pop时，原先的状态再“弹出”，即恢复到原来的对齐状态。通过将默认对齐设为1，我们可以保证结构体中的变量到了二进制文件中时，也是“一个挨一个”的，这样我们以字节流的方式读入数据时，就能保证他们被放到自己应该被放到的位置上去。</p><h3 id="读取FAT12表"><a href="#读取FAT12表" class="headerlink" title="读取FAT12表"></a><a id="chapter1.3">读取FAT12表</a></h3><p>​事实上，我们现在还不急着继续去考虑一些复杂的东西——比如整个FAT12文件系统是怎么组织的——这可能得等我们写到更具体的实现的时候再去考虑，即使是这个链接也没有直观地给出所有内容，我打算后面手绘一张图来更具体地表示。在此之前，我们可以继续做好准备工作——比如先把FAT12表存下来，用16位的unsigned short即可，具体的计算公式和读取方法那个<a href="https://blog.csdn.net/qq_39654127/article/details/88429461">参考资料</a>也给了，需要用到位运算，我这放张图就行了：</p><img src="/blogOfNoob.github.io/teawith/35904/%E4%BB%8E%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%B0FAT12.jpg" class=""><h1 id="“打开”目录项"><a href="#“打开”目录项" class="headerlink" title="“打开”目录项"></a><a id="chapter2">“打开”目录项</a></h1><p>​到此为止，我们已经完成了指令的初步解析、书写了读取BPB（<strong>BIOS Parameter Block</strong>）（BPB也可以<strong>硬编码</strong>，不过建议手动读一下）和目录项的函数，以及在全局存储了一张FAT12表（如果还没做这些事情请翻上去再看看），是时候进一步地接触FAT12文件系统了。</p><p>​接下来我们要做的，首先是定位到需要我们执行相关操作的文件或是文件夹，这都涉及到对目录项的处理。</p><h3 id="数据区的文件夹"><a href="#数据区的文件夹" class="headerlink" title="数据区的文件夹"></a><a id="chapter2.1">数据区的文件夹</a></h3><p>​很明显我们要处理的不仅仅是在根目录区的文件或者文件夹，那在数据区的文件夹又会怎么样呢？</p><p>​为了方便说明，我直接上渣手绘：</p><img src="/blogOfNoob.github.io/teawith/35904/%E6%B8%A3%E7%BB%98.jpg" class="" title="渣手绘勿喷"><p>注：为了方便讲述，这里默认一个簇里面就只有一个扇区。</p><p>​FAT12文件系统的前两个簇是固定簇，而实际表示数据的簇号——或者更确切的说，是FAT12表项的序号从2开始，实际表示数据的“簇”仍然是从0开始。对于一个表示文件的目录项——比如图中的FILE.TXT，其目录项中的第26到27个字节——也就是存储第一个FAT12表项序号低16位的那两个字节，指向的自然是该文件数据的起始簇。如果我们读完了一个簇的内容还没有读到终止，我们就根据这个簇号去查FAT12表，发现其值为0x037，那么我们要把这个值减去2，然后去找对应的簇继续读里面的数据。</p><p>​对于文件夹，它的数据区存放的是其下的目录项。比如假设一个文件夹名叫DIR2，其下面有文件夹DIR22、DIR23、DIR24和文件1.XML, 2.ASM, 3.cpp，那么这个文件夹数据区存放的就是这些文件和文件夹的<strong>相关目录项</strong>（当然由于这次不考虑LFN项，所以自己造的a.img里面可以不出现比如名字叫3.cpp的文件）——当然，还有本身(“.”)和父文件夹(“..”)的目录项，但是这两个目录项<strong>仅限数据区存在</strong>。</p><p>​实际上，虽然一个文件夹下可能没有几个目录，但是如果我们在Linux系统下对一个文件夹用ls -l命令查看其中某个空文件夹的大小，则依然可以看到：</p><img src="/blogOfNoob.github.io/teawith/35904/%E5%B1%95%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%A4%A7%E5%B0%8F.jpg" class="" title="文件夹的大小"><p>​不难发现，这个toMount文件夹有4096B，尽管它下面其实什么都没有。之所以这样巨大，还是考虑到和内存以及Cache的协作，一次移动一个块。</p><p>​因此，比实现CAT还要早的，我们在解析地址这一步就需要关照到<strong>超过512字节的数据的读取</strong>。然而，这也<strong>仅限于数据区</strong>——因为根目录区没这么麻烦，它是连续的。</p><p>​我们当然可以把根目录区和数据区的目录项的遍历分开，不过在取出目录项和<strong>通过目录项的部分属性进行甄别</strong>的过程上，这二者又别无二致。话又说回来，<strong>难道根目录区和数据区的目录项的遍历只能完全分开吗？</strong></p><h3 id="LFN项的产生"><a href="#LFN项的产生" class="headerlink" title="LFN项的产生"></a><a id="chapter2.2">LFN项的产生</a></h3><p>​接下来讨论一点一般性的结论，来看看什么情况下会产生前导LFN（<em>long file name</em>）项吧，有了这个结论，我们可以在解析地址时进行一些节省时间的判断——当然，不去考察问题也不大。</p><p>​对于一般性的目录项的文件名部分，ppt上是这么描述的：</p><p>​<em>8.3 file name. The first 8 characters are the name and the last 3 are the extension.</em></p><p>​这实际上已经指明了一种产生前导LFN项的条件——文件名长度超限。假如一个文件的<em>name</em>部分超过了8个字符，或者扩展名<em>extension</em>部分超过了三个字符，以文件名”123456789.HTML”为例，为了装下它的文件名，我们需要额外的LFN项。比较自由的是，文件夹名也是可以带点的，而且带点的时候同样遵循这一类文件名的限制长度原则。</p><p>​然而，事情并没有这么简单，文件夹名和文件名是可以不带点的，在这种情况下，我们并不能因为不加点就可以将拓展名的三个字符挪用过来，换句话说，不加点的情况下，<strong>文件或者文件夹名长度仍然不能超过8</strong>，否则就会产生LFN项。</p><p>​除了简单的超出限长，还有一些其他的可能导致出现LFN项的情况，不过测试数据里应该不会出现这些。比如说，由于一般的目录项的文件名中出现的英文都是大写的，所以不难想到，如果文件名中带有小写英文字母，也需要前导LFN项来加以描述。再比如，LFN项中的文件名是两个字节两个字节地存储的——这应该是用来应对一些有双字节的“字”的语言的。</p><p>​接下来讨论两个相对而言比较难绷的情况。</p><p>​如果文件名带点，但是文件名或者拓展名没有内容会发生什么？</p><p>​简单点的是没有拓展名的，那么这个点会被无视，而且不管有多少个点，都这样。</p><p>​麻烦一点的是没文件名的，这个点会被视作文件的一部分，而且，扩展名也不复存在，变为一部分的文件名，相应的，要有LFN项存储这个文件名。</p><h3 id="目录项动态变化简析"><a href="#目录项动态变化简析" class="headerlink" title="目录项动态变化简析"></a><a id="chapter2.3">目录项动态变化简析</a></h3><p>​到这里——或者极端一点，到2.1为止，我们就已经完成了一个大体正确的地址解析了。不过，进入下一步之前，我们还得讨论一下当我们对文件执行某些操作时，对应的目录项会发生什么变化。</p><p>​按道理来说应该从文件的增加讲起，但是这样我们无法避开文件的删除对目录项的影响，所以先从删除开始。当我们删除一个文件时，其所关联的目录项——自然也包括LFN项，并不会被直接删除，而是将第一个字节设为<strong>某个定值</strong>。从而我们可以知道这个目录项指向的内容已经被删除。</p><p>​接下来自然是文件的增加。正如我们上面所说，文件删除时并没有直接删除目录项而是用做了标记取代，所以我们得考虑一个“千疮百孔”的文件夹，在这其中，我们创建了很多文件或是文件夹，又删去了一部分不一定连续的文件或者文件夹，这样，摆在我们面前的就是一个<strong>可分配空间</strong>（也包括之前被删除的文件或文件夹的目录项所占据的空间）零散的文件夹。当我们创建文件时，就会寻找到连续的、能够容纳下所有相关联目录项的空间——这也就是说，包括了可能存在的LFN项，然后在这些空间上建立新的目录项。</p><p>​最后是文件或文件夹名的修改。在进行修改时，会先寻找可分配空间生成新的对应目录项，然后删除原先的文件名对应的一个或多个目录项。</p><p>​实际上，我们在这一小节讲述的<strong>绝大多数内容对这次实验是没有用的</strong>——因为这次实验并不涉及到LFN项的处理。即使会有影响的那一小部分，在我们后续的实现与测试中也可以自行发现。放在这里，主要是能帮我们在自己的映像中设计一些较有针对性的用例。</p><h1 id="最后几块砖"><a href="#最后几块砖" class="headerlink" title="最后几块砖"></a><a id="chapter3">最后几块砖</a></h1><p>​在第2大节过后，我们已经完成了地址解析，同时手上可能还有一些有用的工具——比如取出某一文件夹下所有<strong>有效数据项</strong>，以及支持<strong>数据区超过512字节的数据的读取</strong>，那么，只需要进行一些额外的处理，就可以完成我们剩下的工作了！</p><h3 id="早已完成的cat"><a href="#早已完成的cat" class="headerlink" title="早已完成的cat"></a><a id="chapter3.1">早已完成的cat</a></h3><p>​实际上，我们很早就完成了<strong>cat</strong>的重要功能——我们支持了超过512字节数据的读取，在这里只要做一些其他的处理就行了。</p><p>​一个重要的工作是预处理——我们拿到的地址必须是一个文件。</p><p>​另外的工作就是读取映像文件中这个文件所在位置的数据并不断输出了，这个应该也不难做。</p><h3 id="ls命令和-l选项"><a href="#ls命令和-l选项" class="headerlink" title="ls命令和-l选项"></a><a id="chapter3.2">ls命令和-l选项</a></h3><p>​实际上这里做的就是树的遍历——而且实验要求中不要求输出的子文件和目录的顺序，所以广度优先和深度优先都是可以的。</p><p>​直接子目录不统计”.”与”..”，如果用广度优先，这也意味着我们不用把这两个目录放进队列。</p><p>​ls相对较为容易，而-l选项则稍微麻烦一点，主要是子目录中的直接子文件和直接子目录的数量是我们实际遍历完子目录的数据区域才能统计出来的，这也就是说，我们在高层次的打印需要涉及到更深层次的文件和目录信息。我们可以碰到需要打印相关数据的时候直接下去走一遭，然而实际操作中这样涉及到多次软盘的读写，时间上未必占便宜（当然自个编程就不考虑这些了）。</p><p>​另外，整个文件系统其实呈现出的是一个以根目录为树根的树的形状，只不过并没有显式地给出罢了。或许我们可以考虑用某种方法，用<strong>空间换取时间</strong>？</p><p>​在这里还有一些细枝末节的内容，就是红色该怎么打印？</p><p>​助教给的要求中其实写明白了，就是用<strong>\033</strong>（等价的还有<strong>\e</strong>与<strong>\x1b</strong>）。这个字符表示的是esc字符，之后我们再加上’[‘字符，后面跟上颜色相关的代码即可进行<strong>永久性的</strong>颜色切换，具体的内容也不难查询。</p><h3 id="函数传参与联合编译"><a href="#函数传参与联合编译" class="headerlink" title="函数传参与联合编译"></a><a id="chapter3.3">函数传参与联合编译</a></h3><p>​在此之前，我们的输出默认都是用高级语言中的相关输出函数书写的，在这里，我们需要按照实验的要求把它们替换为汇编的输出方式。</p><p>​所以，我们需要先解决一个问题，那就是从高级语言到32位汇编是怎么传参的。以c++为例，到32位汇编的传参是直接把所有参数压栈的。到汇编语言这里需要取出压栈的参数时，就通过栈指针寄存器（esp）中存储的数值加上几个值拿到参数的位置，进而取出其中的参数。至于<strong>参数压栈的顺序</strong>？可以自行尝试一下。</p><p>​如果我们是32位汇编，那么我们需要额外安装32位库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br><span class="line">sudo apt-get install g++-multilib</span><br><span class="line">gcc -m32 main.c func.o</span><br><span class="line">g++ -m32 main.c func.o</span><br></pre></td></tr></table></figure><p>​对于c++的项目，采用gcc编译链接时，<strong>不会自动链接标准STL库</strong>，或者我们可以加上<strong>-lstdc++</strong>这个参数，但这也不完全等同于g++编译。采用g++编译链接时，会自动链接标准STL库，但是需要对来自汇编的函数做一些额外的处理，否则可能找不到来自汇编的函数（这来源于c++带参数的重载造成的函数名变化）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fromAsm</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​至此，整个项目应该已经大差不差了。不过说到底，这也就是我的一些胡言乱语，可能还遗漏了不少东西，有待进一步地验证。</p><h1 id="Lab2问答"><a href="#Lab2问答" class="headerlink" title="Lab2问答"></a><a id="chapter4">Lab2问答</a></h1><p>备注：实验相关内容的问答我就不放了。</p><h3 id="实模式与保护模式"><a href="#实模式与保护模式" class="headerlink" title="实模式与保护模式"></a><a id="chapter4.1">实模式与保护模式</a></h3><p>问题：什么是实模式，什么是保护模式？</p><p>答：实模式是通过<strong>基址+偏移量</strong>可以直接得到地址的模式，其得到的是真实的物理地址，缺点是比较不安全。</p><p>保护模式则不能直接拿到物理地址，而是需要通过选择子从GDT或者LDT拿到段基址再结合偏移量，是从<strong>80286</strong>开始现代操作系统的主要模式。</p><h3 id="选择子"><a href="#选择子" class="headerlink" title="选择子"></a><a id="chapter4.2">选择子</a></h3><p>问题：什么是选择子？</p><p>答：选择子共16位，和段描述符的查找以及段的请求特权相关，放在16位的段选择寄存器中。</p><p>其低2位（<strong>RPL</strong>）表示请求特权级（进程对段的访问权限）。</p><p>第‘2’位表示选择<strong>GDT（全局描述符表）</strong>还是<strong>LDT（局部描述符表）</strong>方式查找段描述符。</p><p>高13位表示其索引的段描述符在相应描述符表中的偏移。</p><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a><a id="chapter4.3">描述符</a></h3><p>问题：什么是描述符？</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/389448141#">全局描述符表 - 知乎 </a>；以及上学期tfgg的最后一份文档。</p><p>为了方便讲述，先把PPT上的图片搬运过来：</p><img src="/blogOfNoob.github.io/teawith/35904/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" class="" title="段描述符"><p>对其中的属性分别讲述：</p><p>段基址：这玩意应该不需要说了。</p><p>段界限：共20位，定义了偏移量的最值。如果是<strong>数据段</strong>，就是最大能增加多少偏移量，如果是<strong>堆栈段</strong>，就是最多能减少多少偏移量，这个可以用来判断越界。</p><p>P：用来表示段描述符是否有效，1为有效。</p><p>G（<strong>Granularity：粒度</strong>）：这一项用来描述<strong>段界限</strong>的单位，如果是0，表示单位为字节，如果为1，意思是单位为4KB。</p><p>S：当S为0，表示系统段描述符；S&#x3D;1，说明是代码段或数据段的描述符。</p><p>TYPE：<strong>受S影响</strong>，建议直接看参考内容。</p><p>D&#x2F;B：分几类情况：</p><p>​对于代码段，如果这一位置<strong>0</strong>，表示采用<strong>16位寻址方式</strong>，如果这一位置为1，表示采用<strong>32位寻址方式</strong>；</p><p>​对于堆栈段，如果这一位置0，表示<strong>使用16位sp寄存器</strong>，如果置1，表示使用<strong>32位esp寄存器</strong>；</p><p>​此外，对于<strong>向下扩展的数据段</strong>，如果这一位置0，表示<strong>最多向下扩展64KB</strong>；如果这一位置1，表示<strong>最多向下扩展4GB</strong>；</p><p>DPL（<strong>Descriptor Privilege Level</strong>）：表示<strong>访问该段所需要的特权级别</strong>。</p><p>AVL：这一位<strong>会被硬件忽略</strong>，似乎没啥用。</p><h3 id="GDT与LDT"><a href="#GDT与LDT" class="headerlink" title="GDT与LDT"></a><a id="chapter4.4">GDT与LDT</a></h3><p>问题：什么是GDT，什么是LDT?</p><p>答：GDT是<strong>全局描述符表</strong>（全局唯一），存放了公用描述符（例如<strong>系统段描述符</strong>）和<strong>包含各进程局部描述符表（LDT）的首地址的描述符</strong>。</p><p>LDT是<strong>局部描述符表</strong>，各个进程都可以有一个自己的LDT，它存放的是该<strong>进程内</strong>使用的描述符。</p><h3 id="GDTR与LDTR"><a href="#GDTR与LDTR" class="headerlink" title="GDTR与LDTR"></a><a id="chapter4.5">GDTR与LDTR</a></h3><p>问题：请分别说明GDTR和LDTR的结构。</p><p>答：GDTR高32位放GDT首地址，低16位放GDT限长（这个寄存器里<strong>相当于存储了全局描述符表的基本信息</strong>）；LDTR共16位，存放一个特殊的选择子，用其查找<strong>当前进程对应的LDT的首地址</strong>（以及其他相关信息，这里PPT上说的不大准确，具体在<a href="#chapter4.7">LDT查找物理地址</a>中可以看到）。</p><h3 id="GDT查找物理地址"><a href="#GDT查找物理地址" class="headerlink" title="GDT查找物理地址"></a><a id="chapter4.6">GDT查找物理地址</a></h3><p>问题：请说明GDT直接查找物理地址的具体步骤。</p><p>（PPT上这张图蛮好，我直接拿过来了）<img src="/blogOfNoob.github.io/teawith/35904/GDT%E6%9F%A5%E6%89%BE%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.jpg" class="" title="GDT查找物理地址"></p><p>答：（段选择子放在<strong>段选择寄存器</strong>中，偏移量在<strong>变址寄存器</strong>中）首先，如果我们从段选择寄存器中拿到的选择子中的第‘2’位为0，表示<strong>用GDT方式查找段描述符</strong>。</p><p>​然后我们从GDTR中取出基址和限长，在判断没有超限后，通过基址加上段选择子的高13位（用作偏移）得到地址，进而获得GDT中的段描述符。</p><p>​在确认合法（不超过限长）且有权限后，用<strong>段描述符中的段基址</strong>加上相关变址寄存器中的<strong>偏移量</strong>，得到物理地址。</p><h3 id="LDT查找物理地址"><a href="#LDT查找物理地址" class="headerlink" title="LDT查找物理地址"></a><a id="chapter4.7">LDT查找物理地址</a></h3><p>问题：请说明通过LDT查找物理地址的具体步骤。</p><p>（PPT上这张图也蛮好，我又直接拿过来了）</p><img src="/blogOfNoob.github.io/teawith/35904/LDT%E6%9F%A5%E8%AF%A2%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.jpg" class="" title="LDT查找物理地址"><p>答：首先我们从段选择寄存器中拿到段选择子，然后检查它的第‘2’位，如果是1，说明使用LDT查找物理地址。</p><p>​那么接下来我们取出GDTR中的基址和限长，判断未超限后，用GDTR中GDT的基址，配合<strong>LDTR中选择子的高13位</strong>获得一个地址，拿到当前进程的LDT的段描述符，<strong>LDT的首地址即段描述符中的基址</strong>，限长即段描述符中的段界限。</p><p>​然后我们在判断不超出LDT的限长后，用LDT的首地址加上<strong>段选择寄存器中存放的段选择子的高13位</strong>拿到相应的段描述符。</p><p>​在判断合法（不超过段限长）且有权限后，用<strong>从LDT中得到的段描述符</strong>的段基址加上偏移量（可能存储在变址寄存器中）得到对应的物理地址。</p><h3 id="根目录区相关问答"><a href="#根目录区相关问答" class="headerlink" title="根目录区相关问答"></a><a id="chapter4.8">根目录区相关问答</a></h3><p>问题：根目录区大小一定么？扇区号是多少？为什么？</p><p>答：根目录区的大小并不一定，这取决于BPB(<strong>BIOS Parameter Block</strong>)中的第17至18个字节（从0开始），这2个字节表示了根目录区目录项数目的最大值，用这个值乘以目录项的大小（32B）即得到根目录区的大小。根目录区的开始扇区号为19，因为根目录区在引导扇区和FAT之后，也就是说在根目录区之前有引导扇区数（为1）+ FAT的数目（一般为2）* FAT的大小（单位为扇区，一般为9）&#x3D; 19，所以根目录区的起始扇区号是19。</p><h3 id="数据区的第一个簇号"><a href="#数据区的第一个簇号" class="headerlink" title="数据区的第一个簇号"></a><a id="chapter4.9">数据区的第一个簇号</a></h3><p>问题：数据区第一个簇号是多少？为什么？</p><p>答：数据区的第一个簇号是2，这是因为FAT12文件系统中，FAT表的起始三个字节（也就是开头两个表项）为定值0xf0、0xff与0xff（也即开头两个表项为<strong>0xff0与0xfff</strong>）。</p><h3 id="FAT表的作用"><a href="#FAT表的作用" class="headerlink" title="FAT表的作用"></a><a id="chapter4.10">FAT表的作用</a></h3><p>问题：FAT（<strong>File Allocation Table</strong>）表的作用？</p><p>答：FAT表的作用是告知操作系统文件存储在磁盘的什么位置。除了第0和第1个表项以外，其他表项中的值的含义是：若值小于0xff7，则表示这个表项对应的簇的存储数据的<strong>下一个簇号</strong>。若值等于0xff7，则表示这个表项对应的簇是<strong>坏簇</strong>，若大于0xff7，则表示这个表项对应的簇已经是所求文件或目录的<strong>最后一个簇</strong>。FAT12的两张表<strong>互为备份</strong>。</p><h3 id="静态链接的过程"><a href="#静态链接的过程" class="headerlink" title="静态链接的过程"></a><a id="chapter4.11">静态链接的过程</a></h3><p>问题：解释静态链接的过程。</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/317478523">一文看懂静态链接 - 知乎 (zhihu.com)</a> 和 《静态链接动态链接》PPT的<strong>第6页的批注</strong>以及<a href="https://blog.csdn.net/shenmingxueIT/article/details/107173906">静态链接——空间的地址和分配_静态链接内存的分配_shenmingik的博客-CSDN博客</a>。</p><p>PS：第5和第6页PPT的内容和批注实际上描述了从两个视角看静态链接的过程，我把他们缝了一下。</p><p>答：静态链接在编译阶段就将静态库加入到可执行文件中去。具体来说，是两件事：<strong>空间和地址分配</strong>，<strong>符号解析与重定位</strong>。<strong>更详细一点地说</strong>，是下述过程：</p><p>假设我们有两个待链接文件a.o和b.o，我们的链接器首先做的是<strong>重定位节</strong>，即将这两个文件中同类型的节（比如.text）合并为同一类型的新的聚合节（在这里就是合并为ab中的.text）。接下来链接器将<strong>运行时存储器地址</strong>赋给新的聚合节，计算出长度，形成映射关系，由于各个指令以及全局变量在目标文件中的偏移是确定的，所以我们已经拥有了所有指令和全局变量的虚拟地址（到此为止，完成<strong>空间和地址分配</strong>）。</p><p>接下来，我们利用<strong>符号表</strong>完成对<strong>符号引用</strong>的解析，将每一个符号引用和定义联系起来，再依据<strong>重定位条目</strong>（或称<strong>重定位段</strong>），通过已知的运行时地址修改代码节和数据节的符号引用（比如某些指令的立即数改成偏移量），到此，完成<strong>符号解析与重定位</strong>，静态链接完成。</p><h3 id="动态链接的过程"><a href="#动态链接的过程" class="headerlink" title="动态链接的过程"></a><a id="chapter4.12">动态链接的过程</a></h3><p>问题：解释动态链接的过程。</p><p>参考：贴个PPT里的参考链接：<a href="https://www.cnblogs.com/linhaostudy/p/10544917.html">参考资料</a></p><p>答：动态链接是指<strong>在编译阶段仅加入一些描述信息</strong>，而<strong>程序执行时再从系统中把相应动态库加载到内存中去</strong>，后者又分为四步：<strong>动态链接器自举</strong>、<strong>装载共享对象</strong>、<strong>重定位与初始化</strong>、<strong>转交控制权</strong></p><p>具体地说：</p><p>假设我们有四个文件：da.c, db.c, mylib.h, 和mylib.c</p><p>这是da.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    fromLib(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是db.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    fromLib(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是mylib.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fromLib</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这是mylib.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fromLib</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>da.c与db.c都用到了mylib.c中的fromLib函数，为了<strong>只加载一次mylib.c到内存</strong>就让两个程序<strong>共享代码</strong>（数据是两个进程私有的），我们可以把lib.c编译成为<strong>共享对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o myLib.so mylib.c</span><br></pre></td></tr></table></figure><p><strong>-shared</strong>的意思是<strong>产生共享对象</strong>，<strong>-fPIC</strong>的意思是告诉编译器产生<strong>与位置无关的代码</strong>（全都是<strong>相对地址</strong>，<strong>没有绝对地址</strong>，这样程序搁哪都能跑）。</p><p>尽管我们是动态链接，但是我们也要让程序知道<strong>跑的时候该去加载什么代码</strong>，所以我们在编译时仍然需要<strong>带上共享对象</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o Dap da.c ./myLib.so</span><br><span class="line">gcc -o Dbp db.c ./myLib.so</span><br></pre></td></tr></table></figure><p>到此为止，我们完成了<strong>编译阶段描述信息的加入</strong>。</p><p>接下来是运行时的工作，分为四步：</p><p>第一步，<strong>动态链接器自举</strong>：</p><p>由于动态链接器也需要多次复用，所以它也是共享对象，也需要重定位，但它又不能使用其他共享对象——甚至自己的函数和全局变量，它的重定位工作即由<strong>自举</strong>（bootstrap）来完成。动态链接器的入口就是自举代码的入口，自举代码将先找到自己的GOT（<strong>全局偏移表 Global Offset Table</strong>，存储<strong>符号对应的偏移量</strong>），在GOT的第一个入口找到<strong>.dynamic段</strong>（这个段存储了<strong>和动态链接相关的信息</strong>，比如动态链接依赖的共享对象，动态链接的符号表和重定位表的偏移以及共享对象初始化代码的地址）的偏移地址，从而从这个段获取动态链接器<strong>自身的符号表和重定位表</strong>的偏移，进而得到动态链接器本身的重定位入口，将<strong>自身的全局变量和函数</strong>重定位，这样，动态链接器就可以使用自己的全局变量和函数了。</p><p>第二步，<strong>装载共享对象</strong>：</p><p>前述的<strong>.dynamic段</strong>存储了<strong>动态链接相关的共享对象</strong>，在这一步，链接器拿到这些共享对象的名字放到一个装载集合中，接下来，链接器一个一个取出集合中的共享对象名，找到他们对应的文件，读取之，将共享对象的代码段和数据段映射到进程空间中。注意，如果这些共享对象<strong>还依赖于其他共享对象</strong>，那就把依赖的共享对象名放到装载集合中。简单地说，就是做一个图的遍历。此外，我们还需要将这些共享对象的符号表和链接器自身的符号表合并，成为<strong>全局符号表</strong>。</p><p>第三步，<strong>重定位与初始化</strong>：</p><p>一些<strong>重要的补充知识</strong>：动态链接的重定位时，并不是简单地修改代码段中的相对地址——这里需要补充一下，假设两个共享对象中有一个<strong>同名符号</strong>，那么即使我们编译的时候规定了哪个程序与哪个共享对象有关，程序中的这个符号也会被动态链接到<strong>先加载的共享对象的同名符号</strong>上，如果是一个共享对象的内部调用被全局符号表中先加载的符号<strong>覆盖</strong>的话，这个共享对象的相对地址也要被修改——这显然违背了共享对象的<strong>地址无关性</strong>。所以，在符号引用时，我们实际引入了所谓的<strong>PLT（Procedure Linkage Table，过程链接表）</strong>与<strong>GOT</strong>（全局偏移表）。符号引用时将会<strong>call</strong>符号对应的PLT——没错，所谓的过程链接表实际上是一段代码段，它的功能是，先在got.plt中查找符号地址，如果没有，再请求链接器去寻找所需地址并填入got.plt中。</p><p>重定位与初始化的<strong>实际过程</strong>：链接器重新遍历可执行的文件和每个共享对象的重定位表，依据进程的全局符号表，将它们的GOT&#x2F;PLT的每个需要重定位的位置进行修正。完成之后，如果某个共享对象中有”.init”段，动态链接器还会执行其中的代码，完成共享对象特有的初始化（一个例子是c++中全局静态对象的构造）（与”.init”段相应的，还有”.finit”段，在进程退出时执行，不过这不关动态链接器的事）。注意，动态链接器执行的只是<strong>共享对象</strong>的.init段，进程自己的会由程序的初始化代码执行。</p><p>第四步，<strong>转交控制权</strong>：</p><p>动态链接器将进程的控制权转交给程序的入口并且开始执行。</p><h3 id="gcc-vs-ld"><a href="#gcc-vs-ld" class="headerlink" title="gcc vs ld"></a><a id="chapter4.13">gcc vs ld</a></h3><p>问题：静态链接相关PPT中为什么使用ld链接而不是gcc？</p><p>回（tu）答（cao）：实际上静态链接相关PPT中似乎只出现了两次ld命令，而且每次ld命令都说了可以换为gcc命令。这里感觉只能回答它们的区别。实际上，这两个东西就链接而言没有原则上的区别——gcc会调用ld，硬要较真的话，gcc会向生成的文件里额外加入“编译器隐式添加的全局加载时库初始化&#x2F;反初始化代码”。当然，gcc还能进行编译。</p><p>gcc默认动态链接。</p><h3 id="Linux下可执行文件的虚拟地址空间"><a href="#Linux下可执行文件的虚拟地址空间" class="headerlink" title="Linux下可执行文件的虚拟地址空间"></a><a id="chapter4.14">Linux下可执行文件的虚拟地址空间</a></h3><p>问题：linux下可执行文件的虚拟地址空间默认从哪里开始分配？</p><p>回答：（主体回答来自gpt，同时从我<strong>“窥屏”</strong>的观察来看，似乎也是这个值）在 Linux 中，可执行文件的虚拟地址空间默认从 0x00400000 开始分配，至于为什么，链接器表示<strong>我就乐意选这个，谁爱管谁管</strong>（之前我还以为有什么高深的原因，结果一查发现。。。）。</p><p><strong>To be continued…</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		做完Lab2，其实感觉还是很有成就感的，但这“火箭”造的说实话不是很友好。好消息是，某位助教的ppt里面的一个参考来源有相当有价值的内容和代码：&lt;a href=&quot;https://blog.csdn.net/qq_39654127/article/details/884</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>未选择的路</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/42176.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/42176.html</id>
    <published>2023-04-02T12:00:24.000Z</published>
    <updated>2023-04-02T15:47:05.130Z</updated>
    
    <content type="html"><![CDATA[<p>Two roads diverged in a yellow wood,</p><p>And sorry I could not travel both</p><p>And be one traveler, long I stood</p><p>And looked down one as far as I could</p><p>To where it bent in the undergrowth.</p><p>Then took the other, as just as fair，</p><p>And having perhaps the better claim,</p><p>Because it was grassy and wanted wear;</p><p>Though as for that the passing there</p><p>Had worn them really about the same.</p><p>And both that morning equally lay</p><p>In leaves no step had trodden back.</p><p>Oh, I kept the first for another day!</p><p>Yet knowing how way leads on to way,</p><p>I doubted if I should ever come back.</p><p>I shall be telling this with a sigh</p><p>Somewhere ages and ages hence:</p><p>Two roads diverged in a wood, and I–</p><p>I took the one less traveled by,</p><p>And that has made all the difference.</p><p>​在很多诗歌中，我最喜欢罗伯特·弗罗斯特的这首《未选择的路》（才不是因为阅读过的诗歌很少呢）。关于这首诗歌的解读有很多，我就简单写写自己的感慨。</p><p>​不断向前走吧！人生没有真正意义上的回头，条件不足时就往前看看，到了终点时，我们还是我们，后头的路照映出出我们的一生。（div.asm）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Two roads diverged in a yellow wood,&lt;/p&gt;
&lt;p&gt;And sorry I could not travel both&lt;/p&gt;
&lt;p&gt;And be one traveler, long I stood&lt;/p&gt;
&lt;p&gt;And looked </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/16107.html"/>
    <id>https://miceforrat.github.io/blogOfNoob.github.io/teawith/16107.html</id>
    <published>2023-04-02T08:59:41.245Z</published>
    <updated>2023-04-02T11:42:51.784Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
