<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>nasm拾遗 | 下午六点的茶会</title><meta name="author" content="Mad Hatter"><meta name="copyright" content="Mad Hatter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="​		如题，这篇帖子也就是在回看自己的代码和助教的PPT的时候标识一些有些容易忘记的内容，属于是想到哪写到哪，大概也没啥参考价值——版权声明我手动关了，这玩意谁爱搬谁搬——大概也不会有人看得上来搬运吧。顺便一提，这篇文章如果没特殊说明就是对32位汇编进行解释。 ​		4.5紧急添加：一些Lab1问题的整理。 ​		章节索引： ​        1. Hello, nasm！ ​		1.1 以db为">
<meta property="og:type" content="article">
<meta property="og:title" content="nasm拾遗">
<meta property="og:url" content="https://miceforrat.github.io/blogOfNoob.github.io/teawith/21438.html">
<meta property="og:site_name" content="下午六点的茶会">
<meta property="og:description" content="​		如题，这篇帖子也就是在回看自己的代码和助教的PPT的时候标识一些有些容易忘记的内容，属于是想到哪写到哪，大概也没啥参考价值——版权声明我手动关了，这玩意谁爱搬谁搬——大概也不会有人看得上来搬运吧。顺便一提，这篇文章如果没特殊说明就是对32位汇编进行解释。 ​		4.5紧急添加：一些Lab1问题的整理。 ​		章节索引： ​        1. Hello, nasm！ ​		1.1 以db为">
<meta property="og:locale">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-03T15:17:01.000Z">
<meta property="article:modified_time" content="2023-04-05T15:23:40.180Z">
<meta property="article:author" content="Mad Hatter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/blogOfNoob.github.io/img/favicon.png"><link rel="canonical" href="https://miceforrat.github.io/blogOfNoob.github.io/teawith/21438.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blogOfNoob.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blogOfNoob.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nasm拾遗',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-05 23:23:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/blogOfNoob.github.io/atom.xml" title="下午六点的茶会" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blogOfNoob.github.io/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/blogOfNoob.github.io/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/blogOfNoob.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blogOfNoob.github.io/img/path.png')"><nav id="nav"><span id="blog-info"><a href="/blogOfNoob.github.io/" title="下午六点的茶会"><span class="site-name">下午六点的茶会</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nasm拾遗</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-03T15:17:01.000Z" title="Created 2023-04-03 23:17:01">2023-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-05T15:23:40.180Z" title="Updated 2023-04-05 23:23:40">2023-04-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nasm拾遗"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>​		如题，这篇帖子也就是在回看自己的代码和助教的PPT的时候标识一些有些容易忘记的内容，属于是想到哪写到哪，大概也没啥参考价值——版权声明我手动关了，这玩意谁爱搬谁搬——大概也不会有人看得上来搬运吧。顺便一提，这篇文章如果没特殊说明就是对32位汇编进行解释。</p>
<p>​		4.5紧急添加：一些Lab1问题的整理。</p>
<p>​		章节索引：</p>
<p>​        <a href="#hellonasm">1. Hello, nasm！</a></p>
<p>​		<a href="#dx">1.1 以db为代表的dx</a></p>
<p>​		<a href="#equAnd$">1.2 equ、$</a></p>
<p>​		<a href="#global">1.3 global</a></p>
<p>​		<a href="#label">1.4 标签</a></p>
<p>​		<a href="#register">1.5 寄存器</a></p>
<p>​        <a href="#int80h">1.6 80h系统调用</a></p>
<p>​       <a href="#function">2. “函数”！</a></p>
<p>​		<a href="#movinstruction">2.1 mov数据传送指令与解引用</a></p>
<p>​		<a href="#jmpinstruction">2.2 jmp指令</a></p>
<p>​		<a href="#pushpop">2.3 压栈与出栈</a></p>
<p>​		<a href="#callinstruction">2.4 call指令与ret指令</a></p>
<p>​		<a href="#parameter">2.5 参数传递？</a></p>
<p>​		<a href="#loops">3. 分支和循环</a></p>
<p>​		<a href="#cmpins">3.1 cmp比较指令</a></p>
<p>​		<a href="#jzins">3.2 以jz为代表的一类跳转指令</a></p>
<p>​		<a href="#addsub">3.3 add与sub</a></p>
<p>​		<a href="#jzins">3.4 DIY一个循环体</a></p>
<p>​		<a href="#lab1">4. Lab1问题整理</a></p>
<p>​		<a href="#lab1.1">4.1 8086的寄存器（详细版本）</a></p>
<p>​		<a href="#lab1.2">4.2 8086的段寄存器</a></p>
<p>​		<a href="#lab1.3">4.3 8086的寻址方式（根据PPT整理）</a></p>
<p>​		<a href="#lab1.4">4.4 主程序和子程序间的传参（根据PPT整理）</a></p>
<p>​		<a href="#lab1.5">4.5 org07c00h伪指令</a></p>
<p>​		<a href="#lab1.6">4.6 int 10h BIOS中断</a></p>
<p>​		<a href="#lab1.7">4.7 times 510 - ($-$ $) db 0</a></p>
<p>​        <a href="#lab1.8">4.8 bochsrc诸参数</a></p>
<p>​		<a href="#lab1.9">4.9 boot.bin放入的扇区</a>	</p>
<p>​		<a href="#lab1.10">4.10 为何不让boot程序加载内核</a>	</p>
<p>​		<a href="#lab1.11">4.11 Loader的作用</a></p>
<p>​		<a href="#lab1.12">4.12 Kernel的作用</a></p>
<h1 id="Hello-nasm"><a href="#Hello-nasm" class="headerlink" title="Hello, nasm!"></a><a id="hellonasm">Hello, nasm!</a></h1><p>​		虽然是想到哪写到哪，多少还是要组织一下文字，那还是找个好参(tou)照(lan)的东西，div的源码显然是不好放出来的，那就以PPT上的hello world作为开始吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">string: db &#x27;Hello World&#x27;, 0Ah</span><br><span class="line">length: equ $-string</span><br><span class="line">section .bss</span><br><span class="line">var: resb 1</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start:</span><br><span class="line">_start:</span><br><span class="line">	mov eax, 4</span><br><span class="line">	mov ebx, 1</span><br><span class="line">	mov ecx, string	</span><br><span class="line">	mov edx, length</span><br><span class="line">	int 80h</span><br><span class="line">	</span><br><span class="line">	mov eax, 1</span><br><span class="line">	mov ebx, 0</span><br><span class="line">	int 80h</span><br></pre></td></tr></table></figure>

<p>​		这里的section是一个<strong>伪指令</strong>，表示规划一段区域，.data, .bss, .text都是区域的代称。值得一提的是，使用<strong>jmp</strong>指令的时候，其指向的地址应当在代码区，也就是.text下面，如果指向其他区域的地址，会引发段错误，如果出现了段错误，可以考虑排查这个方面的问题（这是很容易出现的，尤其是用ide写时手动点回车点到个其他区域的<strong>标记</strong>）</p>
<h3 id="以db为代表的dx"><a href="#以db为代表的dx" class="headerlink" title="以db为代表的dx"></a><a id="dx">以db为代表的dx</a></h3><p>​		.data区内的“变量”，是已经初始化的，比如第一个变量叫做string，db用在.data区，表示其存储单位是字节且是一个初始化了的量，这是一类单位，即“dx”，表示一个初始化的变量的基本单位，后面的x可以有多种表示，例如b就是字节，其他的如下图所示:</p>
<img src="/blogOfNoob.github.io/teawith/21438/xRefTo.jpg" class="" title="x代表什么？">



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string: db &#x27;Hello World&#x27;, 0Ah</span><br><span class="line">length: equ $-string</span><br></pre></td></tr></table></figure>

<p>​		再往下看，string应当是一个地址，或者我们用c语言的概念，不妨叫他char*，它指向一个字符串，叫’Hello World’，后面带上的<strong>0Ah</strong>对应的字符是换行符。</p>
<h3 id="equ、"><a href="#equ、" class="headerlink" title="equ、$"></a><a id="equAnd$">equ、$</a></h3><p>​		下面这行又有个有趣的东西: equ 表示等于，不过实际上我们初始化一般的“变量“用不到它；这里后面跟了个表达式，$表示当前地址，-就是减，string就是上面声明的那个”变量“地址，这样我们得到了字符串的长度，这里也可以看出这些“变量”是<strong>顺序</strong>存放的。也就是说，我们上面的说法实质上并不准确，string这个<strong>标签</strong>并不会指向另外一块区域的字符串，这个字符串实际上就紧跟着这个地址接下来存储。事实上，我们这里只是给这个地址取名叫string，叫cat或是dog实际上也没有什么影响。</p>
<p>​		.bss区内的“变量”是尚未初始化的，下一行的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var: resb 1</span><br></pre></td></tr></table></figure>

<p>中的resb 表示保留以字节为单位的空间，后面跟上的是1。</p>
<p>​		看上去似乎很简单，但实际上并不是这样的，假设我们有两个105字节保留空间的变量，比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testOne：resb 105</span><br><span class="line">testTwo: resb 105</span><br></pre></td></tr></table></figure>

<p>​		当我们将这两个”变量“通过80h系统调用的读入进行初始化，且第一个放入的内容小于105字节时，再利用80h号系统调用，打印105字节长度的内容时，应该会发现会触及到第二个变量的区域内容，一个猜测是变量初始化后多保留的区域就被取消了。所以如果采用.bss区域的变量存储读入的字符串，一定要记得手动计算一下字符串的长度，这也方便填进<strong>int 80h</strong>系统调用的<strong>打印</strong>功能的edx寄存器。</p>
<h3 id="global"><a href="#global" class="headerlink" title="global"></a><a id="global">global</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">global _start:</span><br><span class="line">_start:</span><br><span class="line">	mov eax, 4</span><br><span class="line">	mov ebx, 1</span><br><span class="line">	mov ecx, string	</span><br><span class="line">	mov edx, length</span><br><span class="line">	int 80h</span><br><span class="line">	</span><br><span class="line">	mov eax, 1</span><br><span class="line">	mov ebx, 0</span><br><span class="line">	int 80h</span><br></pre></td></tr></table></figure>

<p>​		下面，终于进入.text区域，也就是代码区了，global将跟在它后面的<strong>标签</strong>标记为全局，从而将其名称添加到对象代码中，简单地说，它使得我们的汇编代码以其后的标记为“入口”——至少在Lab1，这样的认识已经足够了，在Lab1中，我们可以简单的把global后面的<strong>标签</strong>看作是main函数的入口。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a><a id="label">标签</a></h3><p>​		之前提到了很多次”标签“，简单地说，标签就是给一个地址取一个自己想要的名字。事实上，这不仅对代码区的地址适用，在.data和.bss区域同样如此。上面提到过jmp一个非代码区的地址会出段错误——这说明这一步至少是过了编译的，也即，jmp一个”变量名“是合法的，而我们知道jmp指令后面跟着的是地址，所以这里的“变量名”就是一个地址。或者武断地讲，其实并没有什么“变量”，“变量名”连同“函数”一样，都只是某个地址的别名罢了，只不过为了解释方便，我们可以用“变量”或者“函数”来指代不同区域的标签指向的地址。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><a id="register">寄存器</a></h3><p>​		接下来到了我们在后续的编程中相当需要依赖的内容之一，也就是寄存器了。</p>
<p>​		我们当然有很多寄存器可以用，不过，要完成Lab1（Lab2我还没做到要用汇编的那一步），我们实际上只需要用到eax, ebx, ecx, edx这几个寄存器就能完成全部任务了，不过在这里还是解释一下寄存器们都是干啥的：</p>
<img src="/blogOfNoob.github.io/teawith/21438/register.jpg" class="" title="寄存器的大小">

<p>​		显然的，eax，edx，ecx与ebx都是32位的，也就是extended（大概吧，我瞎说的）；如果64位就是rax。ax寄存器指向eax的低16位，而ah是ax的高8位，al是ax的低8位。当然，这几个寄存器的功能并不完全一样，我查到的结果是：</p>
<p>​		eax 是累加器(accumulator), 它是很多加法乘法指令的缺省寄存器；</p>
<p>​		ebx 是基地址(base)寄存器, 在内存寻址时存放基地址；</p>
<p>​		ecx是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器；</p>
<p>​		edx 则总是被用来放整数除法产生的余数。</p>
<p>​		不过我们似乎不需要管这些，大数除法的实现并不一定要用到mul和div两种指令，edx就给解放出来了，ebx我实际用下来乱放数据好像没影响，loop和rep似乎也用不到（想压行的例外）。更何况我们在Lab1中进行数学运算的数据8位足矣（参与运算的最大数值是字符串长度你敢信？），用32位多少有点大材小用。</p>
<p>​		esi与edi寄存器好像是源和目的索引寄存器，不过暂且用不到，Lab1里面我们用abcd四个数据寄存器能开16个8位的暂存空间，根本用不到这俩寄存器。</p>
<p>​		一些以s结尾的寄存器是段寄存器，但实际上只要我们代码别写太长，应该用不到。</p>
<p>​		下面还有两个esp和ebp，顾名思义，ebp一直指向栈底，esp一直指向栈顶。Lab1我们仍然没必要用到他们，不过在Lab2我们就不得不用了——在Lab2，我们不能那么自由的操纵寄存器了，到那时，我们可以关注一下一般情况下的函数传参。	</p>
<p>​		这里的解释并不完全详细，详细的解释跳转</p>
<h3 id="80h系统调用"><a href="#80h系统调用" class="headerlink" title="80h系统调用"></a><a id="int80h">80h系统调用</a></h3><p>​		int 80h很复杂。简单地说，eax固定存储系统调用号，而其他寄存器存储相关参数。</p>
<p>​		我们只需要用到三种：eax置1、eax置3与eax置4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">mov ebx, 0</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>

<p>​		先来看看最简单的eax置1，也就是exit，这个系统调用应该没啥说的，就是退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 3</span><br><span class="line">mov ebx, 0</span><br><span class="line">mov ecx, string	</span><br><span class="line">mov edx, lengthone</span><br><span class="line">int 80h</span><br><span class="line">mov eax, 4</span><br><span class="line">mov ebx, 1</span><br><span class="line">mov ecx, string	</span><br><span class="line">mov edx, lengthone</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>

<p>​		eax置3和eax置4我们不妨放在一起看。3表示读，4表示写。ebx中放的貌似是表示哪一种io流，反正按图中这种写法总归没问题。ecx放置的是一个地址，用于存储读入或是要写的字符串，edx放置读或写的长度。值得一提的是，在读的时候，虽然我们规定了长度，但实际上如果我们没有输入比edx中长度更长的字符串，读取内容也是到我们敲下回车为止，仅此而已。关于IO的部分我后面可能会再展开写一点。</p>
<p>​		到这里为止，我们分析完了一开始给出的hello world代码，就这一部分，我们居然写了两千多个词，不过好消息是，我们知道了db、resb的含义，int 80h系统调用的一些知识，以及对寄存器有了一些初步的了解。</p>
<h1 id="“函数”"><a href="#“函数”" class="headerlink" title="“函数”!"></a><a id="function">“函数”!</a></h1><p>​		现在我们完成了hello world的书写，不过到此就满足了吗？比如说这次大数除法，我们的读和写要调用两次，可能中间还有一些测试需求需要打印一些信息，为此，我们可以考虑进行“函数”的封装，实现代码段的反复使用。</p>
<p>​		还是来看看PPT给出的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SECTION .data</span><br><span class="line">msg     db      &#x27;Hello, brave new world!&#x27;, 0Ah</span><br><span class="line"> </span><br><span class="line">SECTION .text</span><br><span class="line">global  _start</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line">    mov     eax, msg        </span><br><span class="line">    call    strlen          </span><br><span class="line"> </span><br><span class="line">    mov     edx, eax        </span><br><span class="line">    mov     ecx, msg</span><br><span class="line">    mov     ebx, 1</span><br><span class="line">    mov     eax, 4</span><br><span class="line">    int     80h</span><br><span class="line"> </span><br><span class="line">    mov     ebx, 0</span><br><span class="line">    mov     eax, 1</span><br><span class="line">    int     80h</span><br><span class="line">    </span><br><span class="line">;; strlen(str: eax)-&gt;len: eax</span><br><span class="line">strlen:                     </span><br><span class="line">    push    ebx</span><br><span class="line">    mov     ebx, eax</span><br><span class="line"> </span><br><span class="line">nextchar:</span><br><span class="line">    cmp     byte [eax], 0</span><br><span class="line">    jz      finished</span><br><span class="line">    inc     eax</span><br><span class="line">    jmp     nextchar</span><br><span class="line"> </span><br><span class="line">finished:</span><br><span class="line">    sub     eax, ebx</span><br><span class="line">    pop     ebx </span><br><span class="line">    ret                   </span><br></pre></td></tr></table></figure>

<h3 id="mov数据传送指令与解引用"><a href="#mov数据传送指令与解引用" class="headerlink" title="mov数据传送指令与解引用"></a><a id="movinstruction">mov数据传送指令与解引用</a></h3><p>​		在开始接下来的分析之前，我们不妨先看看数据传送指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, ebx</span><br><span class="line">mov bl, 1</span><br><span class="line">mov bh, byte[getfrom]</span><br><span class="line">mov dword[fillin], ecx</span><br><span class="line">mov cl, byte[edx]</span><br></pre></td></tr></table></figure>

<p>​		这里列出了mov的一些用法。其核心格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dest, src</span><br></pre></td></tr></table></figure>

<p>​		第一种是将ebx寄存器中的内容mov给eax；第二种是将bl中置为1。到第三种这里出现了解引用**[]**，其含义是，对于方框中的地址，用方框前的变量将其取出，也就是说，第三种将getfrom这个地址的一个字节取出。第四种将ecx中的32位数据存到fillin这个地址处。既然方框中放置一个地址，那么第五种也是可以成立的，即将edx指向的地址以字节方式取出放到cl中。</p>
<h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a><a id="jmpinstruction">jmp指令</a></h3><p>​		前文我们提到了很多次<strong>jmp指令</strong>，事实上，这个指令对于我们的编程有着重要的作用——比如用一些简单的指令实现循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp LABLE_LOOP</span><br></pre></td></tr></table></figure>

<p>​		jmp指令的格式相当简单，指令名称之后就是一个地址，当然我们有偷懒的方法，比如使用<strong>标签</strong>减少自己的计算。然而，jmp有其局限性，比如如果需要跳回来。我们当然可以跳来跳去，但是系统给我们提供了更集成和智能的指令——call和ret。</p>
<h3 id="压栈与出栈"><a href="#压栈与出栈" class="headerlink" title="压栈与出栈"></a><a id="jmpinstruction">压栈与出栈</a></h3><p>​		在正式进入call与ret之前，我们还需要补上一点内容，那就是栈。基本的概念之前的课都涉及到了我再搬一遍也没意思，直接看指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push edx</span><br><span class="line">pop eax</span><br></pre></td></tr></table></figure>

<p>​		栈和我们选用的系统息息相关，在32位编译下，上述写法是合法的，而若以64位进行编译，则会在编译时出错，需要改用rdx与rax。</p>
<p>​		实际上，这两个指令并不只做一件事，他们除了将相关的值压栈和出栈之外，还修改了栈指针寄存器（ESP），将edx压栈之后，esp的内容增加4，为什么是加4呢？这是因为32位编译下，我们向栈中压入了32位，即4个字节的内容，故而加4。同样的逻辑下，当我们修改一块以db为单位的存储空间——姑且认为是一个byte数组时，我们存地址的寄存器每次即加1。</p>
<p>​		32位下据说有两个非常棒的指令pusha和popa，不过我没怎么用，就不误人子弟了。</p>
<h3 id="call指令与ret指令"><a href="#call指令与ret指令" class="headerlink" title="call指令与ret指令"></a><a id="callinstruction">call指令与ret指令</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call strlen</span><br><span class="line">;do something</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>​		call指令的格式同样相当简单。它的功能是，如果要段间跳转，就将call的<strong>下一条</strong>指令的段基址（存于CS）和相对偏移(存于IP寄存器，也即指令指针寄存器)入栈，如果是段内跳转，则只将相对偏移（存于IP寄存器）入栈；接下来执行jmp命令的功能。ret的作用恰好相反，将对应的值出栈并存储到相应寄存器中。这样在ret之后，我们就能执行call指令之后的指令。</p>
<p>​		由于系统已经给我们包装好了相关功能，所以如果我们要实现“函数”调用，那就直接用call和ret就可以了。</p>
<h3 id="参数传递？"><a href="#参数传递？" class="headerlink" title="参数传递？"></a><a id="parameter">参数传递？</a></h3><p>​		前文说过，汇编里面其实所谓的“变量”和“函数”都是标签，前面也解释了call指令和ret指令，其实非常简单，这就引出了一个问题，我们该怎么进行参数传递？</p>
<p>​		汇编代码是极度自由的，这体现在我们可以自由地操纵大多数寄存器，以ppt中这个函数为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;; strlen(str: eax)-&gt;len: eax</span><br><span class="line">strlen:                     </span><br><span class="line">    push    ebx</span><br><span class="line">    mov     ebx, eax</span><br><span class="line"> </span><br><span class="line">nextchar:</span><br><span class="line">    cmp     byte [eax], 0</span><br><span class="line">    jz      finished</span><br><span class="line">    inc     eax</span><br><span class="line">    jmp     nextchar</span><br><span class="line"> </span><br><span class="line">finished:</span><br><span class="line">    sub     eax, ebx</span><br><span class="line">    pop     ebx </span><br><span class="line">    ret     </span><br></pre></td></tr></table></figure>

<p>​		注释写的算是比较明白的了，我们在eax中放置一个地址——这里它的意义是一个字符串的起始地址，那么我们所需要做的就是在“函数调用“之前往我们设定好的”函数“的对应寄存器中存入参数即可。这种参数传递在我们只写汇编的时候非常舒服。</p>
<p>​		那么如果我们用高级语言函数调用汇编的代码时，怎么办呢？之前学习高级语言时，我们知道函数调用时也会发生参数压栈，所以我们可以用栈指针寄存器减去一定的数值来获取相关参数，不过压栈的顺序我不是很清楚（还没做到），故而在此就暂且不说了。</p>
<p>​		我们只写汇编时还有一种暴力的传参手段，就是直接在.bss区开个变量临时存值，但是这样就会增加访存次数，造成时间消耗增大，不过在这里影响暂且不大。</p>
<h1 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a><a id="loops">分支和循环</a></h1><p>​		到上面为止，我们应该是把函数调用讲了个七七八八，不过我们还没有仔细看这个strlen函数是怎么实现的呢，接下来，我们刚好借着这些新指令来顺便看一看如何用已有的汇编指令实现简单的循环和分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;; strlen(str: eax)-&gt;len: eax</span><br><span class="line">strlen:                     </span><br><span class="line">    push    ebx</span><br><span class="line">    mov     ebx, eax</span><br><span class="line"> </span><br><span class="line">nextchar:</span><br><span class="line">    cmp     byte [eax], 0</span><br><span class="line">    jz      finished</span><br><span class="line">    inc     eax</span><br><span class="line">    jmp     nextchar</span><br><span class="line"> </span><br><span class="line">finished:</span><br><span class="line">    sub     eax, ebx</span><br><span class="line">    pop     ebx </span><br><span class="line">    ret     </span><br></pre></td></tr></table></figure>

<h3 id="cmp比较指令"><a href="#cmp比较指令" class="headerlink" title="cmp比较指令"></a><a id="cmpins">cmp比较指令</a></h3><p>​		无论是高级语言中的if还是while还是for，都离不开<strong>比较</strong>。在汇编里，比较可以用<strong>cmp</strong>指令实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, ebx</span><br><span class="line">cmp dl, byte[toCmp]</span><br><span class="line">cmp dh, 100</span><br></pre></td></tr></table></figure>

<p>​		cmp指令后跟上两个待比较的<strong>位数相同</strong>的内容。比较的结果并不放在寄存器中，而是影响CPU中的FLAG，那么我们该怎么访问到这些FLAG呢？系统同样给了我们大量的现成指令，这就是以jz为代表的一类跳转指令。</p>
<h3 id="以jz为代表的一类跳转指令"><a href="#以jz为代表的一类跳转指令" class="headerlink" title="以jz为代表的一类跳转指令"></a><a id="jzins">以jz为代表的一类跳转指令</a></h3><p>​		jz的意思是，如果ZERO FLAG被设置（set），则进行跳转，以无符号数的比较为例，我们有以下这些跳转指令：</p>
<img src="/blogOfNoob.github.io/teawith/21438/unsignedcmp.jpg" class="" title="无符号下的跳转指令">

<p>​		实际上，对于Lab1来说，无符号数和有符号数差别不大，ja与jna换成了jg和jng，jb与jnb换成了jl和jnl，用哪个问题都不大。</p>
<p>​		至此，我们有了比较和跳转，可以着手实现一个简单的分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	cmp al, 10</span><br><span class="line">	jz LABEL_OUT</span><br><span class="line">	;do something</span><br><span class="line">	</span><br><span class="line">LABEL_OUT:</span><br><span class="line">	;do some other things</span><br></pre></td></tr></table></figure>

<p>​		这就是一个简单的<strong>分支</strong>了，依据我们的需要，可以往里面加入不同的代码。</p>
<h3 id="add与sub"><a href="#add与sub" class="headerlink" title="add与sub"></a><a id="addsub">add与sub</a></h3><p>​		add和sub，顾名思义，一个加，一个减，他们的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add dest, src</span><br><span class="line">sub dest, src</span><br></pre></td></tr></table></figure>

<p>​		对于add，结果为dest &#x3D; dest + src, 结果存在dest对应的寄存器中，dest只能是一个寄存器。减法同理。</p>
<p>​		有了加和减，实现类似for循环也不是什么难事了，在此之前，还有两个实用（省打字数目）的指令：inc与dec：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inc eax</span><br><span class="line">dec bh</span><br></pre></td></tr></table></figure>

<p>​		这两个指令顾名思义，是进行自增和自减的指令，使其后寄存器中的值每次”增加“或”减少“1。</p>
<h3 id="DIY一个循环体"><a href="#DIY一个循环体" class="headerlink" title="DIY一个循环体"></a><a id="jzins">DIY一个循环体</a></h3><p>​		现在我们有了四个实用的指令：比较指令用于判断是否满足退出循环的条件，条件跳转指令实行判断满足条件后的跳转，无条件跳转指令实现回环往复，add和sub这一类指令实现更新——当然绝不止这两个指令能实现这一要求。</p>
<p>​		我们可以先搭一个最简单的循环，也就是死循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL_LOOP:</span><br><span class="line">	;do something</span><br><span class="line">	jmp LABEL_LOOP</span><br></pre></td></tr></table></figure>

<p>​		接下来我们要着手跳出循环了，我们以将al中的值（不妨初始化为0）和10比较，如果相等作为跳出循环的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	mov al, 0</span><br><span class="line">LABEL_LOOP:</span><br><span class="line">	cmp al, 10</span><br><span class="line">	jz LABEL_OUT_LOOP</span><br><span class="line">	;do something</span><br><span class="line">	jmp LABEL_LOOP</span><br><span class="line">	</span><br><span class="line">LABEL_OUT_LOOP:</span><br><span class="line">	;do some other things</span><br></pre></td></tr></table></figure>

<p>​		最后如果我们想让他执行10步（11次比较），则将增量设置为1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	mov al, 0</span><br><span class="line">LABEL_LOOP:</span><br><span class="line">	cmp al, 10</span><br><span class="line">	jz LABEL_OUT_LOOP</span><br><span class="line">	inc al</span><br><span class="line">	;do something</span><br><span class="line">	jmp LABEL_LOOP</span><br><span class="line">	</span><br><span class="line">LABEL_OUT_LOOP:</span><br><span class="line">	;do some other things</span><br></pre></td></tr></table></figure>

<p>​		至此，一个简单的循环体搭建完毕。</p>
<p>​		事实上，考虑另外一种方法，也即我们之前写的<strong>分支</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	cmp al, 10</span><br><span class="line">	jz LABEL_OUT</span><br><span class="line">	;do something</span><br><span class="line">	</span><br><span class="line">LABEL_OUT:</span><br><span class="line">	;do some other things</span><br></pre></td></tr></table></figure>

<p>​		只需要在不满足条件时进行自增及反复回跳即可做到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	mov al, 0</span><br><span class="line">LABEL_LOOP:</span><br><span class="line">	cmp al, 10</span><br><span class="line">	jz LABEL_OUT_LOOP</span><br><span class="line">	inc al</span><br><span class="line">	;do something</span><br><span class="line">	jmp LABEL_LOOP</span><br><span class="line">	</span><br><span class="line">LABEL_OUT_LOOP:</span><br><span class="line">	;do some other things</span><br></pre></td></tr></table></figure>

<p>​		有了这个简单的小循环体，我们能做很多事，比如实现之前的strlen，甚至我们可以用80h系统调用中进行写的方法实现一个经典的getchar直到特定字符。</p>
<h1 id="Lab1问题整理"><a href="#Lab1问题整理" class="headerlink" title="Lab1问题整理"></a><a id="lab1">Lab1问题整理</a></h1><h3 id="8086的寄存器（详细版本）"><a href="#8086的寄存器（详细版本）" class="headerlink" title="8086的寄存器（详细版本）"></a><a id="lab1.1">8086的寄存器（详细版本）</a></h3><p>8086有哪5类寄存器？请分别举例说明其作⽤。 </p>
<p>参考来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115915986">x86汇编之——8086寄存器讲解 - 知乎 (zhihu.com)</a></p>
<p>答：分为数据寄存器（ax,bx,cx, dx）、指针寄存器(sp, bp)、变址寄存器(si-source index, di-destination index)、控制寄存器(flag, ip-instruction pointer)、段寄存器(cs-code segment, ds-data segment, es-extra segment, ss-stack segment)</p>
<p>通用寄存器中：</p>
<p>数据寄存器：</p>
<p>ax:累加器，在通用的暂存数据以外的作用有比如存16位乘法的低位结果。</p>
<p>bx:除了通用功能外，还有专属功能寻址，作为一种<strong>基址</strong>寄存器。</p>
<p>cx：计数器，除了通用功能还能配合loop指令。</p>
<p>dx：除了通用功能，还能存除法结果的高位。</p>
<p>指针寄存器：</p>
<p>sp：stack pointer，指向栈顶（确切地说存了偏移量）。</p>
<p>bp: base pointer，指向栈底（确切地说存的是偏移量）。</p>
<p>变址寄存器：</p>
<p>si：源变址寄存器</p>
<p>di：目的变址寄存器</p>
<p>这俩作为通用寄存器当然可以暂存数据，但主要的功能还是存放地址偏移，配合相关的段寄存器进行寻址。</p>
<p>控制寄存器：</p>
<img src="/blogOfNoob.github.io/teawith/21438/registers.jpg" class="" title="flag寄存器">

<p>FLAG寄存器中，一部分是和比较结果有关的，其他和一些别的功能有关。</p>
<p>IP 指令指针寄存器，常配合CS寄存器进行指令的取出。</p>
<p>段寄存器：见下文</p>
<h3 id="8086的段寄存器"><a href="#8086的段寄存器" class="headerlink" title="8086的段寄存器"></a><a id="lab1.2">8086的段寄存器</a></h3><p>有哪些段寄存器，它们的作⽤是什么？ </p>
<p>答：</p>
<p>CS：代码段寄存器，配合IP寄存器指向需要执行的指令。</p>
<p>DS：数据段寄存器</p>
<p>ES：附加段寄存器</p>
<p>上面这两个都可以用来配合数据寻址。</p>
<p>SS：堆栈段寄存器：SS:BP 指向栈底，SS:SP指向栈顶</p>
<h3 id="8086的寻址方式（根据PPT）"><a href="#8086的寻址方式（根据PPT）" class="headerlink" title="8086的寻址方式（根据PPT）"></a><a id="lab1.3">8086的寻址方式（根据PPT）</a></h3><p>什么是寻址？8086有哪些寻址⽅式？ </p>
<p>答：寻址就是找到操作数的地址。</p>
<p>8086的寻址方式有： 立即寻址、直接寻址、寄存器寻址、寄存器间接寻址、寄存器相对寻址 、基址加变址、相对基址加变址</p>
<p>具体来说：立即寻址就是直接在操作数中给出值，直接寻址是在操作数中给出地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 10	;这是立即寻址</span><br><span class="line">mov ax, word[1234H]	;这是直接寻址</span><br></pre></td></tr></table></figure>

<p>寄存器寻址将操作数放在寄存器中，而寄存器间接寻址将操作数的地址置于寄存器中，寄存器相对寻址使寄存器中的地址加上一个立即数得到真正的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, bx				;这是寄存器寻址</span><br><span class="line">mov ax, word[bx]		;这是寄存器间接寻址</span><br><span class="line">mov ax, word[si + 3]	;这是寄存器相对寻址</span><br></pre></td></tr></table></figure>

<p>基址加变址的操作方法是将基址寄存器（BX, BP）中的地址加上变址寄存器（SI, DI）的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, word[bx + di]	;这是基址加变址</span><br></pre></td></tr></table></figure>

<p>相对基址加变址还存在额外偏移：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, word[bx + di + 3]</span><br></pre></td></tr></table></figure>



<h3 id="主程序和子程序间的传参（根据PPT）"><a href="#主程序和子程序间的传参（根据PPT）" class="headerlink" title="主程序和子程序间的传参（根据PPT）"></a><a id="lab1.4">主程序和子程序间的传参（根据PPT）</a></h3><p>主程序与⼦程序之间如何传递参数？ </p>
<p>答：有以下几种：</p>
<p>通过寄存器传参（向寄存器中置入我们想要传递的参数）；</p>
<p>通过约定的地址传参；</p>
<p>以及通过堆栈传参：利用栈指针寄存器等拿到堆栈中的值（或者确知无风险的情况下采用pop）。</p>
<h3 id="伪指令-org07c00h"><a href="#伪指令-org07c00h" class="headerlink" title="伪指令 org07c00h"></a><a id="lab1.5">伪指令 org07c00h</a></h3><p>解释 boot.asm ⽂件中 org 07c00h 的作⽤。如果去掉这⼀句，整个程序应该怎么修改？ </p>
<p>答：org本身并不会把代码段放在07c00h处（放在这是BIOS干的），它只是告诉编译器，这个代码段会放在这，这样编译器就会把绝对地址自动加上07c00h。如果去掉这一句，我们就需要在所有<strong>直接给出的</strong>相对地址后面手动加上07c00h:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, bootMessage + 07c00h</span><br></pre></td></tr></table></figure>

<h3 id="int-10h-BIOS中断"><a href="#int-10h-BIOS中断" class="headerlink" title="int 10h BIOS中断"></a><a id="lab1.6">int 10h BIOS中断</a></h3><p>解释 int 10h 的功能。 </p>
<p>参考来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hua19880705/article/details/8125706">汇编中的10H中断int 10h详细说明_hua19880705的博客-CSDN博客</a></p>
<p>答：汇编中的10h 中断是由BIOS对显示器和屏幕所提供的服务程序。使用int 10h服务程序时，必须先指定ah寄存器为显示服务编号之一，以指定需要调用的功用。</p>
<p>以boot.asm中出现的ah置013h为例，其功能是：在Teletype模式下显示字符串。</p>
<p>bh置入页码，bl置入属性，具体来说是底色和字色。cx置入字符串长度。dh与dl分别置入行列坐标。</p>
<p>al置入显示输出方式，具体来说：</p>
<p>0—— 字符串中只含显示字符，其显示属性在BL中。显示后，光标位置不变</p>
<p>1——字符串中只含显示字符，其显示属性在BL中。显示后，光标位置改变</p>
<p>2 ——字符串中含显示字符和显示属性。显示后，光标位置不变</p>
<p>3——字符串中含显示字符和显示属性。显示后，光标位置改变</p>
<h3 id="times-510-db-0"><a href="#times-510-db-0" class="headerlink" title="times 510 - ($-$ $) db 0"></a><a id="lab1.7">times 510 - ($-$ $) db 0</a></h3><p>解释 boot.asm ⽂件中 times 510-($-$$) db 0 的作⽤。 </p>
<p>答：times表示重复汇编，在times后面跟着的表达式会被重复指定的次数。</p>
<p>510 -($-$$) 就是这个被指定的次数，$表示当前行被汇编后的地址，而$$表示当前段开始处被汇编后的的地址。</p>
<p>db 0 表示存入0。</p>
<p>综上所述，这个指令的作用就是填满到510为止的空间。</p>
<p>下一行再加上魔数（0xaa55，也就是结束标志），这样刚好512字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">times 	510-($-$$)	db	0	; 填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">dw 	0xaa55				; 结束标志</span><br></pre></td></tr></table></figure>

<h3 id="bochsrc诸参数"><a href="#bochsrc诸参数" class="headerlink" title="bochsrc诸参数"></a><a id="lab1.8">bochsrc诸参数</a></h3><p>解释 bochsrc 中各参数的含义。 </p>
<p>答：我们写的配置文件是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">megs:32</span><br><span class="line">display_library: sdl2 </span><br><span class="line">floppya: 1_44=a.img, status=inserted</span><br><span class="line">boot: floppy</span><br></pre></td></tr></table></figure>

<p>megs表示虚拟机内存大小（32即32MB）；display_library表示采用的图形库，这里填sdl2即采用sdl2库；boot表示虚拟机启动方式，floppy表示从软盘启动；floppya是虚拟机外设，确切地说，规范了第一个驱动该是啥，这里的参数中1_44是软盘媒体类型，status &#x3D; inserted表示初始状态是插入，简单来说这个语句就是以a.img为软盘文件。</p>
<h3 id="boot-bin放入的扇区"><a href="#boot-bin放入的扇区" class="headerlink" title="boot.bin放入的扇区"></a><a id="lab1.9">boot.bin放入的扇区</a></h3><p>boot.bin 应该放在软盘的哪⼀个扇区？为什么？ </p>
<p>答：放在第0磁头第0磁道第1扇区。</p>
<p>原因：计算机开机启动后，首先经过BIOS开机自检，检查硬件设备是否有问题，如果没有，将会根据BIOS 的启动项配置选择引导设备，我们选择的是从软盘启动。于是接下来BIOS检测第0磁头第0磁道第1扇区是否以0xaa55结束，如果是，即认为这是引导扇区，将他放在7c00h处，并将处理器执行权交给这段程序。故而boot.bin需要放在第0磁头第0磁道第1扇区。</p>
<h3 id="为何不让boot程序直接加载内核"><a href="#为何不让boot程序直接加载内核" class="headerlink" title="为何不让boot程序直接加载内核"></a><a id="lab1.10">为何不让boot程序直接加载内核</a></h3><p>为什么不让Boot程序直接加载内核，⽽需要先加载Loader再加载内核？</p>
<p>答：boot程序受到512字节的限制，而我们在加载内核时还需要做很多其他事——比如设置保护模式。应该说512字节远远不够，所以要先加载Loader，将控制权交给他，再由loader加载内核。</p>
<h3 id="Loader的作用"><a href="#Loader的作用" class="headerlink" title="Loader的作用"></a><a id="lab1.11">Loader的作用</a></h3><p> Loader的作⽤有哪些？ </p>
<p>答：Loader的作用主要有：</p>
<p>跳入保护模式（从而才得以访问1M以上的内存）；</p>
<p>启动内存分页；</p>
<p> 从kernel.bin中读取内核，并放入内存，然后跳转到内核所在的开始地址，运行内核。（查找方式和boot查找loader时类似，不过由于我们实验中的kernel是在操作系统层面下编写的，存在一些无关信息，所以需要loader来提取需要放入内存的部分）</p>
<h3 id="Kernel的作用"><a href="#Kernel的作用" class="headerlink" title="Kernel的作用"></a><a id="lab1.12">Kernel的作用</a></h3><p>Kernel的作⽤有哪些？</p>
<p>答：这是真正的操作系统，其中的内核具有内存管理，进程调度，图像显示，网络访问等功能。</p>
<p><strong>To be continued…</strong></p>
<p>​		</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogOfNoob.github.io/teawith/19536.html" title="OSLab3随笔"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">OSLab3随笔</div></div></a></div><div class="next-post pull-right"><a href="/blogOfNoob.github.io/teawith/35904.html" title="OSLab2随笔"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">OSLab2随笔</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/blogOfNoob.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mad Hatter</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blogOfNoob.github.io/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/blogOfNoob.github.io/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/blogOfNoob.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">萌新一枚，随手记记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-nasm"><span class="toc-number">1.</span> <span class="toc-text">Hello, nasm!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5db%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84dx"><span class="toc-number">1.0.1.</span> <span class="toc-text">以db为代表的dx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equ%E3%80%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">equ、$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#global"><span class="toc-number">1.0.3.</span> <span class="toc-text">global</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">1.0.4.</span> <span class="toc-text">标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.0.5.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80h%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.6.</span> <span class="toc-text">80h系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%9C%E5%87%BD%E6%95%B0%E2%80%9D"><span class="toc-number">2.</span> <span class="toc-text">“函数”!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mov%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">2.0.1.</span> <span class="toc-text">mov数据传送指令与解引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">2.0.2.</span> <span class="toc-text">jmp指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E6%A0%88%E4%B8%8E%E5%87%BA%E6%A0%88"><span class="toc-number">2.0.3.</span> <span class="toc-text">压栈与出栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E6%8C%87%E4%BB%A4%E4%B8%8Eret%E6%8C%87%E4%BB%A4"><span class="toc-number">2.0.4.</span> <span class="toc-text">call指令与ret指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-number">2.0.5.</span> <span class="toc-text">参数传递？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.</span> <span class="toc-text">分支和循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cmp%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="toc-number">3.0.1.</span> <span class="toc-text">cmp比较指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5jz%E4%B8%BA%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%B8%80%E7%B1%BB%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">3.0.2.</span> <span class="toc-text">以jz为代表的一类跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add%E4%B8%8Esub"><span class="toc-number">3.0.3.</span> <span class="toc-text">add与sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DIY%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E4%BD%93"><span class="toc-number">3.0.4.</span> <span class="toc-text">DIY一个循环体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab1%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Lab1问题整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-number">4.0.1.</span> <span class="toc-text">8086的寄存器（详细版本）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086%E7%9A%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.0.2.</span> <span class="toc-text">8086的段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8086%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%88%E6%A0%B9%E6%8D%AEPPT%EF%BC%89"><span class="toc-number">4.0.3.</span> <span class="toc-text">8086的寻址方式（根据PPT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%AD%90%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BC%A0%E5%8F%82%EF%BC%88%E6%A0%B9%E6%8D%AEPPT%EF%BC%89"><span class="toc-number">4.0.4.</span> <span class="toc-text">主程序和子程序间的传参（根据PPT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4-org07c00h"><span class="toc-number">4.0.5.</span> <span class="toc-text">伪指令 org07c00h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-10h-BIOS%E4%B8%AD%E6%96%AD"><span class="toc-number">4.0.6.</span> <span class="toc-text">int 10h BIOS中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#times-510-db-0"><span class="toc-number">4.0.7.</span> <span class="toc-text">times 510 - ($-$ $) db 0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bochsrc%E8%AF%B8%E5%8F%82%E6%95%B0"><span class="toc-number">4.0.8.</span> <span class="toc-text">bochsrc诸参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boot-bin%E6%94%BE%E5%85%A5%E7%9A%84%E6%89%87%E5%8C%BA"><span class="toc-number">4.0.9.</span> <span class="toc-text">boot.bin放入的扇区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%AE%A9boot%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8"><span class="toc-number">4.0.10.</span> <span class="toc-text">为何不让boot程序直接加载内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.0.11.</span> <span class="toc-text">Loader的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.0.12.</span> <span class="toc-text">Kernel的作用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/39322.html" title="一些手册的简单描述">一些手册的简单描述</a><time datetime="2023-05-31T15:29:17.000Z" title="Created 2023-05-31 23:29:17">2023-05-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/37800.html" title="secII淘金">secII淘金</a><time datetime="2023-05-30T15:42:27.000Z" title="Created 2023-05-30 23:42:27">2023-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/35878.html" title="OSLab4随笔">OSLab4随笔</a><time datetime="2023-05-22T15:14:32.000Z" title="Created 2023-05-22 23:14:32">2023-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/19536.html" title="OSLab3随笔">OSLab3随笔</a><time datetime="2023-05-07T07:43:33.000Z" title="Created 2023-05-07 15:43:33">2023-05-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blogOfNoob.github.io/teawith/21438.html" title="nasm拾遗">nasm拾遗</a><time datetime="2023-04-03T15:17:01.000Z" title="Created 2023-04-03 23:17:01">2023-04-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/blogOfNoob.github.io/img/path.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Mad Hatter</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blogOfNoob.github.io/js/utils.js"></script><script src="/blogOfNoob.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>